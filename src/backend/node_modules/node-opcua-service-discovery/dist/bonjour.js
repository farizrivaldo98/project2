"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BonjourHolder = exports._announceServerOnMulticastSubnet = exports.serviceToString = exports.isSameService = exports.announcementToServiceConfig = exports.releaseBonjour2 = exports.acquireBonjour2 = exports.releaseBonjour = exports.acquireBonjour = void 0;
/**
 * @module node-opcua-service-discovery
 */
// tslint:disable:no-console
const util_1 = require("util");
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_object_registry_1 = require("node-opcua-object-registry");
const sterfive_bonjour_service_1 = require("sterfive-bonjour-service");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
let gBonjour;
let gBonjourRefCount = 0;
const registry = new node_opcua_object_registry_1.ObjectRegistry();
function errorCallback(err) {
    console.log(" ERROR received from Bonjour", err.message);
}
function acquireBonjour() {
    const bonjour = new sterfive_bonjour_service_1.Bonjour();
    registry.unregister(bonjour);
    return bonjour;
}
exports.acquireBonjour = acquireBonjour;
function releaseBonjour(bonjour, callback) {
    bonjour.unpublishAll(() => {
        bonjour.destroy(callback);
        registry.unregister(bonjour);
    });
}
exports.releaseBonjour = releaseBonjour;
function acquireBonjour2() {
    if (gBonjourRefCount === 0) {
        // will start the Bonjour service
        debugLog("Starting Bonjour");
        gBonjour = new sterfive_bonjour_service_1.Bonjour(undefined, errorCallback);
        registry.register(gBonjour);
    }
    gBonjourRefCount++;
    return gBonjour;
}
exports.acquireBonjour2 = acquireBonjour2;
function releaseBonjour2(bonjour) {
    gBonjourRefCount--;
    (0, node_opcua_assert_1.assert)(gBonjourRefCount >= 0);
    if (gBonjourRefCount === 0) {
        if (!gBonjour) {
            throw new Error("internal error");
        }
        const tmp = gBonjour;
        gBonjour = undefined;
        // will stop the Bonjour service
        tmp.unpublishAll(() => {
            tmp.destroy();
            registry.unregister(tmp);
            debugLog("Releasing Bonjour");
        });
    }
}
exports.releaseBonjour2 = releaseBonjour2;
function announcementToServiceConfig(announcement) {
    const serviceConfig = {
        name: announcement.name,
        port: announcement.port,
        protocol: "tcp",
        host: announcement.host,
        txt: {
            caps: announcement.capabilities.sort().join(","),
            path: announcement.path
        },
        type: "opcua-tcp"
    };
    return serviceConfig;
}
exports.announcementToServiceConfig = announcementToServiceConfig;
function isSameService(a, b) {
    var _a, _b, _c, _d;
    if (!a && !b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    return a.port === b.port && ((_a = a.txt) === null || _a === void 0 ? void 0 : _a.path) === ((_b = b.txt) === null || _b === void 0 ? void 0 : _b.path) && a.name === b.name && ((_c = a.txt) === null || _c === void 0 ? void 0 : _c.caps) === ((_d = b.txt) === null || _d === void 0 ? void 0 : _d.caps);
}
exports.isSameService = isSameService;
const serviceToString = (service) => {
    return "host" + service.host + " type=" + service.type + service.name + " on port " + service.port + " txt " + JSON.stringify(service.txt);
};
exports.serviceToString = serviceToString;
// function waitServiceUp(serviceConfig: ServiceConfig, callback: () => void) {
//     const multicastDNS = new Bonjour();
//     const browser = multicastDNS.find({
//         protocol: "tcp",
//         type: "opcua-tcp"
//     });
//     const onUp = (service: Service) => {
//         if (doDebug) {
//             debugLog(chalk.cyan("    waitServiceUp is up with  ", serviceToString(service)));
//         }
//         if (isSameService(service, serviceConfig)) {
//             browser.removeAllListeners("up");
//             multicastDNS.destroy();
//             callback();
//         }
//     };
//     browser.on("up", onUp);
// }
// function waitServiceDown(serviceConfig: ServiceConfig, callback: () => void) {
//     const multicastDNS = new Bonjour();
//     const browser = multicastDNS.find({
//         protocol: "tcp",
//         type: "opcua-tcp"
//     });
//     const onDown = (service: Service) => {
//         if (doDebug) {
//             debugLog(chalk.cyan("    waitServiceDown down with  ", serviceToString(service)));
//         }
//         if (isSameService(service, serviceConfig)) {
//             browser.removeAllListeners("down");
//             multicastDNS.destroy();
//             callback();
//         }
//     };
//     browser.on("down", onDown);
// }
function _announceServerOnMulticastSubnet(multicastDNS, serviceConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const port = serviceConfig.port;
            (0, node_opcua_assert_1.assert)(typeof port === "number");
            (0, node_opcua_assert_1.assert)(multicastDNS, "bonjour must have been initialized?");
            debugLog(chalk.cyan("  announceServerOnMulticastSubnet", (0, exports.serviceToString)(serviceConfig)));
            // waitServiceUp(serviceConfig, () => {
            //     // istanbul ignore next
            //     if (doDebug) {
            //         debugLog(chalk.cyan("  announcedOnMulticastSubnet done ", serviceToString(serviceConfig)));
            //     }
            //     //    resolve(service);
            // });
            const service = multicastDNS.publish(Object.assign(Object.assign({}, serviceConfig), { probe: false }));
            service.on("error", (err) => {
                debugLog("bonjour ERROR received ! ", err.message);
                debugLog("params = ", serviceConfig);
            });
            service.on("up", () => {
                debugLog("_announceServerOnMulticastSubnet: bonjour UP received ! ", (0, exports.serviceToString)(serviceConfig));
                resolve(service);
            });
            service.start();
        });
    });
}
exports._announceServerOnMulticastSubnet = _announceServerOnMulticastSubnet;
class BonjourHolder {
    constructor() {
        this.pendingAnnouncement = false;
    }
    /**
     *
     * @param announcement
     * @returns
     */
    announcedOnMulticastSubnet(announcement) {
        return __awaiter(this, void 0, void 0, function* () {
            debugLog(chalk.yellow("\n\nentering announcedOnMulticastSubnet"));
            const serviceConfig = announcementToServiceConfig(announcement);
            if (this._service && this.serviceConfig) {
                // verify that Announcement has changed
                if (isSameService(serviceConfig, this.serviceConfig)) {
                    debugLog(" Announcement ignored as it has been already made", announcement.name);
                    debugLog("exiting announcedOnMulticastSubnet-2", false);
                    return false; // nothing changed
                }
            }
            (0, node_opcua_assert_1.assert)(!this._multicastDNS, "already called ?");
            this._multicastDNS = acquireBonjour();
            this.pendingAnnouncement = true;
            this.serviceConfig = serviceConfig;
            this._service = yield _announceServerOnMulticastSubnet(this._multicastDNS, serviceConfig);
            this.pendingAnnouncement = false;
            debugLog(chalk.yellow("exiting announcedOnMulticastSubnet-3", true));
            return true;
        });
    }
    isStarted() {
        return !!this._multicastDNS;
    }
    /**
     *
     * @param announcement
     * @param callback
     * @private
     */
    announcedOnMulticastSubnetWithCallback(announcement, callback) {
        callback(new Error("Internal Error"));
    }
    /**
     * @private
     */
    stopAnnouncedOnMulticastSubnet() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pendingAnnouncement) {
                debugLog(chalk.bgWhite.redBright("stopAnnnouncedOnMulticastSubnet is pending : let's wait a little bit and try again"));
                // wait until announcement is done
                yield new Promise((resolve) => setTimeout(resolve, 500));
                return this.stopAnnouncedOnMulticastSubnet();
            }
            debugLog(chalk.green("\n\nentering stop_announcedOnMulticastSubnet = ", this.serviceConfig ? (0, exports.serviceToString)(this.serviceConfig) : "<null>"));
            if (!this._service) {
                debugLog(chalk.green("leaving stop_announcedOnMulticastSubnet = no service"));
                return;
            }
            // due to a wrong declaration of Service.stop in the d.ts file we
            // need to use a workaround here
            const that_service = this._service;
            const that_multicastDNS = this._multicastDNS;
            this._service = undefined;
            this._multicastDNS = undefined;
            this.serviceConfig = undefined;
            const proxy = (callback) => {
                if (that_multicastDNS && that_service.stop) {
                    // waitServiceDown(that_service, () => {
                    //     debugLog(chalk.green("stop_announcedOnMulticastSubnet, ", serviceToString(that_service)));
                    // });
                    that_service.stop((err) => {
                        debugLog(chalk.green("service stopped err=", err));
                        that_multicastDNS.unpublishAll(() => {
                            releaseBonjour(that_multicastDNS, () => {
                                callback();
                            });
                        });
                    });
                    return;
                }
                else {
                    callback();
                }
            };
            const stop = (0, util_1.promisify)(proxy);
            yield stop.call(this);
            debugLog(chalk.green("leaving stop_announcedOnMulticastSubnet = done"));
            debugLog(chalk.green("leaving stop_announcedOnMulticastSubnet stop announcement completed"));
        });
    }
    stopAnnouncedOnMulticastSubnetWithCallback(callback) {
        callback(new Error("Internal Error"));
    }
}
exports.BonjourHolder = BonjourHolder;
BonjourHolder.prototype.announcedOnMulticastSubnetWithCallback = (0, util_1.callbackify)(BonjourHolder.prototype.announcedOnMulticastSubnet);
BonjourHolder.prototype.stopAnnouncedOnMulticastSubnetWithCallback = (0, util_1.callbackify)(BonjourHolder.prototype.stopAnnouncedOnMulticastSubnet);
//# sourceMappingURL=bonjour.js.map