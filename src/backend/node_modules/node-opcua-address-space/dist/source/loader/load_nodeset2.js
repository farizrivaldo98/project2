"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSetLoader = void 0;
/* eslint-disable max-statements */
/**
 * @module node-opcua-address-space
 */
const util_1 = require("util");
const chalk = require("chalk");
const ec = require("node-opcua-basic-types");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_basic_types_1 = require("node-opcua-basic-types");
const node_opcua_data_access_1 = require("node-opcua-data-access");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_extension_object_1 = require("node-opcua-extension-object");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_service_call_1 = require("node-opcua-service-call");
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_xml2json_1 = require("node-opcua-xml2json");
const semver = require("semver");
const namespace_post_step_1 = require("./namespace_post_step");
const ensure_datatype_extracted_1 = require("./ensure_datatype_extracted");
const decode_xml_extension_object_1 = require("./decode_xml_extension_object");
const make_semver_compatible_1 = require("./make_semver_compatible");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
function __make_back_references(namespace) {
    const namespaceP = namespace;
    for (const node of namespaceP.nodeIterator()) {
        node.propagate_back_references();
    }
    for (const node of namespaceP.nodeIterator()) {
        node.install_extra_properties();
    }
}
function make_back_references(addressSpace) {
    const addressSpacePrivate = addressSpace;
    addressSpacePrivate.suspendBackReference = false;
    addressSpace.getNamespaceArray().map(__make_back_references);
}
function stringToUInt32Array(str) {
    const array = str ? str.split(",").map((value) => parseInt(value, 10)) : null;
    return array;
}
function convertAccessLevel(accessLevel) {
    const accessLevelN = parseInt(accessLevel || "1", 10); // CurrentRead if not specified
    return (0, node_opcua_data_model_1.makeAccessLevelFlag)(accessLevelN);
}
function makeDefaultVariant(addressSpace, dataTypeNode, valueRank) {
    let variant = { dataType: node_opcua_variant_1.DataType.Null };
    const nodeDataType = addressSpace.findNode(dataTypeNode);
    if (nodeDataType && nodeDataType.basicDataType) {
        const basicDataType = nodeDataType.basicDataType;
        if (basicDataType === node_opcua_variant_1.DataType.Variant) {
            /// we don't now what is the variant
            return undefined;
        }
        if (basicDataType === node_opcua_variant_1.DataType.ExtensionObject) {
            return { dataType: node_opcua_variant_1.DataType.ExtensionObject, value: null };
        }
        const builtInType = (0, node_opcua_factory_1.getBuiltInType)(node_opcua_variant_1.DataType[basicDataType]);
        if (builtInType === undefined || builtInType === null) {
            errorLog("Cannot find builtInType for ", basicDataType);
            return { dataType: node_opcua_variant_1.DataType.Null };
        }
        const dv = builtInType.defaultValue;
        const value = typeof dv === "function" ? dv() : dv;
        let arrayType;
        /*
         *  * n > 1                     : the Value is an array with the specified number of dimensions.
         *  * OneDimension (1):           The value is an array with one dimension.
         *  * OneOrMoreDimensions (0):    The value is an array with one or more dimensions.
         *  * Scalar (-1):                The value is not an array.
         *  * Any (-2):                   The value can be a scalar or an array with any number of dimensions.
         *  * ScalarOrOneDimension (-3):  The value can be a scalar or a one dimensional array.
         */
        switch (valueRank) {
            case -3: //  ScalarOrOneDimension (-3):
            case -2: // any
            case -1:
                arrayType = node_opcua_variant_1.VariantArrayType.Scalar;
                variant = { dataType: basicDataType, value, arrayType };
                break;
            case 0: // one or more dimension
            case 1: // one dimension
                arrayType = node_opcua_variant_1.VariantArrayType.Array;
                variant = { dataType: basicDataType, value: [], arrayType };
                break;
            default:
                arrayType = node_opcua_variant_1.VariantArrayType.Matrix;
                variant = { dataType: basicDataType, value: [], arrayType, dimensions: [] };
                break;
        }
    }
    return variant;
}
function makeNodeSetParserEngine(addressSpace, options) {
    const addressSpace1 = addressSpace;
    addressSpace1.suspendBackReference = true;
    options.loadDeprecatedNodes = options.loadDeprecatedNodes === undefined ? true : options.loadDeprecatedNodes;
    options.loadDraftNodes = options.loadDraftNodes || false;
    const postTasks = [];
    const postTasks0_InitializeVariable = [];
    const postTasks0_DecodePojoString = [];
    const postTasks1_InitializeVariable = [];
    const postTasks2_AssignedExtensionObjectToDataValue = [];
    let alias_map = {};
    /**
     * @param aliasName
     */
    function addAlias(aliasName, nodeIdInXmlContext) {
        (0, node_opcua_assert_1.assert)(typeof nodeIdInXmlContext === "string");
        const nodeId = _translateNodeId(nodeIdInXmlContext);
        (0, node_opcua_assert_1.assert)(nodeId instanceof node_opcua_nodeid_1.NodeId);
        alias_map[aliasName] = nodeId;
        addressSpace1.getNamespace(nodeId.namespace).addAlias(aliasName, nodeId);
    }
    let namespace_uri_translation = {};
    let namespaceCounter = 0;
    let found_namespace_in_uri = {};
    let models = [];
    let performedCalled = false;
    function _reset_namespace_translation() {
        debugLog("_reset_namespace_translation");
        namespace_uri_translation = {};
        found_namespace_in_uri = {};
        namespaceCounter = 0;
        alias_map = {};
        models = [];
        performedCalled = false;
    }
    function _translateNamespaceIndex(innerIndex) {
        const namespaceIndex = namespace_uri_translation[innerIndex];
        // istanbul ignore next
        if (namespaceIndex === undefined) {
            debugLog("Warning: namespace_uri_translation = ", namespace_uri_translation);
            errorLog("namespace_uri_translation", namespace_uri_translation);
            throw new Error("_translateNamespaceIndex() ! Cannot find namespace definition for index " + innerIndex);
        }
        return namespaceIndex;
    }
    function _internal_addReferenceType(params) {
        // istanbul ignore next
        if (!(params.nodeId instanceof node_opcua_nodeid_1.NodeId)) {
            throw new Error("invalid param");
        } // already translated
        const namespace = addressSpace1.getNamespace(params.nodeId.namespace);
        namespace.addReferenceType(params);
    }
    function _internal_createNode(params) {
        // istanbul ignore next
        if (!(params.nodeId instanceof node_opcua_nodeid_1.NodeId)) {
            throw new Error("invalid param expecting a valid nodeId");
        } // already translated
        const namespace = addressSpace1.getNamespace(params.nodeId.namespace);
        return namespace.internalCreateNode(params);
    }
    function _register_namespace_uri_in_translation_table(namespaceUri) {
        if (found_namespace_in_uri[namespaceUri]) {
            return;
        }
        const namespace = addressSpace1.getNamespace(namespaceUri);
        // istanbul ignore next
        if (!namespace) {
            throw new Error("cannot find namespace for " +
                namespaceUri +
                "\nplease make sure to initialize your address space with the corresponding nodeset files");
        }
        found_namespace_in_uri[namespaceUri] = namespace;
        const index_in_xml = namespaceCounter;
        namespaceCounter++;
        namespace_uri_translation[index_in_xml] = namespace.index;
        doDebug &&
            debugLog(" _register_namespace_uri = ", namespaceUri, "index in Xml=", index_in_xml, " index in addressSpace", namespace.index);
    }
    function _add_namespace(model) {
        if (model.requiredModels.length > 0) {
            // check that required models exist already in the address space
            for (const requiredModel of model.requiredModels) {
                const existingNamespace = addressSpace1.getNamespace(requiredModel.modelUri);
                // istanbul ignore next
                if (!existingNamespace) {
                    errorLog("Please ensure that the required namespace", requiredModel.modelUri, "is loaded first when loading", model.modelUri);
                    throw new Error("LoadNodeSet : Cannot find namespace for " + requiredModel.modelUri);
                }
                /**
                 *  from https://reference.opcfoundation.org/Core/docs/Part6/F.2/
                 *  The version of the model defined in the UANodeSet.
                 *  This is a human-readable string and not intended for programmatic comparisons.
                 */
                const isLowerVersion = (existingVersion, requiredVersion) => {
                    const existingSemver = (0, make_semver_compatible_1.makeSemverCompatible)(existingVersion);
                    const requiredSemver = (0, make_semver_compatible_1.makeSemverCompatible)(requiredVersion);
                    return semver.lt(existingSemver, requiredSemver);
                };
                if (isLowerVersion(existingNamespace.version, requiredModel.version)) {
                    errorLog("Expecting ", requiredModel.modelUri, " with version to be at least", requiredModel.version, " but namespace version is ", existingNamespace.version);
                }
                if (existingNamespace.publicationDate.getTime() < requiredModel.publicationDate.getTime()) {
                    errorLog("Expecting ", requiredModel.modelUri, " with publicationDate at least ", requiredModel.publicationDate.toUTCString(), " but namespace publicationDate is ", existingNamespace.publicationDate.toUTCString());
                }
            }
        }
        let namespace;
        // Model must not be already registered
        const existingNamespace = addressSpace1.getNamespace(model.modelUri);
        if (existingNamespace) {
            // special treatment for namespace 0
            // istanbul ignore else
            if (model.modelUri === "http://opcfoundation.org/UA/") {
                namespace = existingNamespace;
            }
            else {
                throw new Error(" namespace already registered " + model.modelUri);
            }
        }
        else {
            namespace = addressSpace1.registerNamespace(model.modelUri);
            namespace.setRequiredModels(model.requiredModels);
        }
        namespace.version = model.version;
        namespace.publicationDate = model.publicationDate || namespace.publicationDate;
        return namespace;
    }
    const reg = /ns=([0-9]+);(.*)/;
    function _translateNodeId(nodeId) {
        if (alias_map[nodeId]) {
            return alias_map[nodeId];
        }
        const m = nodeId.match(reg);
        if (m) {
            const namespaceIndex = _translateNamespaceIndex(parseInt(m[1], 10));
            nodeId = "ns=" + namespaceIndex + ";" + m[2];
        }
        return (0, node_opcua_nodeid_1.resolveNodeId)(nodeId);
    }
    function _translateReferenceType(refType) {
        return _translateNodeId(refType);
    }
    /**
     * convert a nodeId
     *
     * @method convertToNodeId
     * @param nodeId {String|null}
     * @return {NodeId}
     *
     * @example
     *    convertToNodeId("String") => resolve alias
     *    convertToNodeId("i=58")   => resolve to nodeId in namespace 0
     *    convertToNodeId("ns=1;i=100") => convert namespace from xml namespace
     *                                      table to corresponding namespace in addressSpace
     */
    function convertToNodeId(nodeIdLike) {
        // treat alias
        if (!nodeIdLike) {
            return null;
        }
        const nodeId = _translateNodeId(nodeIdLike);
        return addressSpace1.resolveNodeId(nodeId);
    }
    function convertQualifiedName(qualifiedName) {
        const qn = (0, node_opcua_data_model_1.stringToQualifiedName)(qualifiedName);
        // Xx if (qn.namespaceIndex > 0) {
        qn.namespaceIndex = _translateNamespaceIndex(qn.namespaceIndex);
        // Xx }
        return qn;
    }
    const state_Alias = {
        finish() {
            addAlias(this.attrs.Alias, this.text);
        }
    };
    const references_parser = {
        init() {
            this.parent.obj.references = [];
            this.array = this.parent.obj.references;
        },
        parser: {
            Reference: {
                finish() {
                    this.parent.array.push({
                        isForward: this.attrs.IsForward === undefined ? true : this.attrs.IsForward === "false" ? false : true,
                        nodeId: convertToNodeId(this.text),
                        referenceType: _translateReferenceType(this.attrs.ReferenceType)
                    });
                }
            }
        }
    };
    const state_UAObject = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.Object;
            this.obj.isAbstract = ec.coerceBoolean(attrs.IsAbstract);
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
            this.obj.eventNotifier = ec.coerceByte(attrs.EventNotifier) || 0;
            this.obj.symbolicName = attrs.SymbolicName || null;
            this.isDraft = attrs.ReleaseStatus === "Draft";
            this.isDeprecated = attrs.ReleaseStatus === "Deprecated";
        },
        finish() {
            if (canIngore({ isDraft: this.isDraft, isDeprecated: this.isDeprecated }, this.obj)) {
                return;
            }
            _internal_createNode(this.obj);
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            Description: {
                finish() {
                    this.parent.obj.description = this.text;
                }
            },
            References: references_parser
        }
    };
    const state_UAObjectType = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.ObjectType;
            this.obj.isAbstract = ec.coerceBoolean(attrs.IsAbstract);
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
            this.obj.eventNotifier = ec.coerceByte(attrs.EventNotifier) || 0;
        },
        finish() {
            _internal_createNode(this.obj);
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            Description: {
                finish() {
                    this.parent.obj.description = this.text;
                }
            },
            References: references_parser
        }
    };
    const state_UAReferenceType = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.ReferenceType;
            this.obj.isAbstract = ec.coerceBoolean(attrs.IsAbstract);
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
        },
        finish() {
            _internal_addReferenceType(this.obj);
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            Description: {
                finish() {
                    this.parent.obj.description = this.text;
                }
            },
            InverseName: {
                finish() {
                    this.parent.obj.inverseName = this.text;
                }
            },
            References: references_parser
        }
    };
    const pendingSimpleTypeToRegister = [];
    const state_UADataType = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.DataType;
            this.obj.isAbstract = ec.coerceBoolean(attrs.IsAbstract) || false;
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
            this.obj.displayName = "";
            this.obj.description = "";
            this.obj.symbolicName = attrs.SymbolicName;
            this.isDraft = attrs.ReleaseStatus === "Draft";
            this.isDeprecated = attrs.ReleaseStatus === "Deprecated";
            this.definitionFields = [];
        },
        finish() {
            if (canIngore({ isDraft: this.isDraft, isDeprecated: this.isDeprecated }, this.obj)) {
                return;
            }
            const definitionFields = this.definitionFields;
            // replace DataType with nodeId, and description to LocalizedText
            definitionFields.map((x) => {
                if (x.description) {
                    x.description = { text: x.description };
                }
                if (x.displayName) {
                    x.displayName = { text: x.displayName };
                }
                if (x.dataType) {
                    x.dataType = convertToNodeId(x.dataType);
                }
                return x;
            });
            this.obj.partialDefinition = definitionFields;
            let capturedDataTypeNode = _internal_createNode(this.obj);
            const processBasicDataType = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
                const definitionName = capturedDataTypeNode.browseName.name;
                const isStructure = capturedDataTypeNode.isStructure();
                const isEnumeration = capturedDataTypeNode.isEnumeration();
                if (!isEnumeration && !isStructure && capturedDataTypeNode.nodeId.namespace !== 0) {
                    // add a custom basic type that is not a structure nor a enumeration
                    pendingSimpleTypeToRegister.push({ name: definitionName, dataTypeNodeId: capturedDataTypeNode.nodeId });
                }
                capturedDataTypeNode = undefined;
            });
            postTasks.push(processBasicDataType);
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            Description: {
                finish() {
                    this.parent.obj.description = this.text;
                }
            },
            References: references_parser,
            Definition: node_opcua_xml2json_1._definitionParser
        }
    };
    const localizedText_parser = {
        LocalizedText: {
            init() {
                this.localizedText = {};
            },
            parser: {
                Locale: {
                    finish() {
                        this.parent.localizedText.locale = this.text.trim();
                    }
                },
                Text: {
                    finish() {
                        this.parent.localizedText.text = this.text.trim();
                    }
                }
            }
        }
    };
    const qualifiedName_parser = {
        QualifiedName: {
            init() {
                this.qualifiedName = {
                    namespaceIndex: 0,
                    name: null
                };
            },
            parser: {
                Name: {
                    finish() {
                        this.parent.qualifiedName.name = this.text.trim();
                    }
                },
                NamespaceIndex: {
                    finish() {
                        const ns = parseInt(this.text, 10);
                        const t = _translateNodeId((0, node_opcua_nodeid_1.resolveNodeId)(`ns=${ns};i=1`).toString());
                        this.parent.qualifiedName.namespaceIndex = t.namespace;
                    }
                }
            }
        }
    };
    const nodeId_parser = {
        NodeId: {
            init() {
                this.nodeId = "";
            },
            parser: {
                Identifier: {
                    finish() {
                        this.parent.nodeId = _translateNodeId((0, node_opcua_nodeid_1.resolveNodeId)(this.text.trim()).toString());
                    }
                }
            }
        }
    };
    const enumValueType_parser = {
        EnumValueType: {
            init() {
                this.enumValueType = new node_opcua_types_1.EnumValueType({
                    description: undefined,
                    displayName: undefined,
                    value: [0, 0] // Int64
                });
            },
            parser: {
                Value: {
                    finish() {
                        // Low part
                        this.parent.enumValueType.value[1] = parseInt(this.text, 10);
                    }
                },
                DisplayName: Object.assign(Object.assign({}, localizedText_parser.LocalizedText), { finish() {
                        this.parent.enumValueType.displayName = Object.assign({}, this.localizedText);
                    } }),
                Description: Object.assign(Object.assign({}, localizedText_parser.LocalizedText), { finish() {
                        this.parent.enumValueType.description = Object.assign({}, this.localizedText);
                    } })
            },
            finish() {
                this.enumValueType = new node_opcua_types_1.EnumValueType(this.enumValueType);
            }
        }
    };
    const argument_parser = {
        Argument: {
            init() {
                this.argument = new node_opcua_service_call_1.Argument({});
            },
            parser: {
                Name: {
                    finish() {
                        this.parent.argument.name = this.text.trim();
                    }
                },
                DataType: {
                    parser: {
                        Identifier: {
                            finish() {
                                this.parent.parent.argument.dataType = _translateNodeId((0, node_opcua_nodeid_1.resolveNodeId)(this.text.trim()).toString());
                            }
                        }
                    }
                },
                ValueRank: {
                    finish() {
                        this.parent.argument.valueRank = parseInt(this.text.trim(), 10);
                    }
                },
                ArrayDimensions: {
                    finish() {
                        // xx  this.parent.argument.arrayDimensions =[];
                    }
                },
                Description: {
                    init() {
                        this._text = "";
                        this.locale = null;
                        this.text = null;
                    },
                    parser: {
                        Locale: {
                            init() {
                                this.text = "";
                            },
                            finish() {
                                this.parent.locale = this.text.trim();
                            }
                        },
                        Text: {
                            finish() {
                                this.text = this.text || "";
                                this.parent._text = this.text.trim();
                            }
                        }
                    },
                    finish() {
                        this.parent.argument.description = (0, node_opcua_data_model_1.coerceLocalizedText)(this._text);
                    }
                }
            },
            finish() {
                // xx this.argument = new Argument(this.argument);
            }
        }
    };
    const Range_parser = {
        Range: {
            init() {
                this.range = new node_opcua_types_1.Range({});
            },
            parser: {
                Low: {
                    finish() {
                        this.parent.range.low = parseFloat(this.text);
                    }
                },
                High: {
                    finish() {
                        this.parent.range.high = parseFloat(this.text);
                    }
                }
            }
        }
    };
    const EUInformation_parser = {
        EUInformation: {
            init() {
                this.euInformation = new node_opcua_data_access_1.EUInformation({});
            },
            parser: {
                NamespaceUri: {
                    finish() {
                        this.parent.euInformation.namespaceUri = this.text;
                    }
                },
                UnitId: {
                    finish() {
                        this.parent.euInformation.unitId = parseInt(this.text, 10);
                    }
                },
                DisplayName: Object.assign(Object.assign({}, localizedText_parser.LocalizedText), { finish() {
                        this.parent.euInformation.displayName = Object.assign({}, this.localizedText);
                    } }),
                Description: Object.assign(Object.assign({}, localizedText_parser.LocalizedText), { finish() {
                        this.parent.euInformation.description = Object.assign({}, this.localizedText);
                    } })
            },
            finish() {
                this.euInformation = new node_opcua_data_access_1.EUInformation(this.euInformation);
            }
        }
    };
    const _extensionObject_inner_parser = {
        TypeId: {
            parser: {
                Identifier: {
                    finish() {
                        const typeDefinitionId = this.text.trim();
                        const self = this.parent.parent; // ExtensionObject
                        self.typeDefinitionId = (0, node_opcua_nodeid_1.resolveNodeId)(typeDefinitionId);
                    }
                }
            }
        },
        Body2: new node_opcua_xml2json_1.FragmentClonerParser(),
        Body: {
            parser: {
                Argument: argument_parser.Argument,
                EUInformation: EUInformation_parser.EUInformation,
                EnumValueType: enumValueType_parser.EnumValueType,
                Range: Range_parser.Range
            },
            startElement(elementName, attrs) {
                const self = this.parent; // ExtensionObject
                self.extensionObject = null;
                self.extensionObjectPojo = null;
                if (!Object.prototype.hasOwnProperty.call(this.parser, elementName)) {
                    // treat it as a opaque XML bloc for the time being
                    // until we find the definition of this object, so we know how to interpret the fields
                    this._cloneFragment = new node_opcua_xml2json_1.InternalFragmentClonerReaderState();
                    this.engine._promote(this._cloneFragment, this.engine.currentLevel, elementName, attrs);
                }
            },
            finish() {
                const self = this.parent; // ExtensionObject
                // typeDefinitionId is also the "Default XML" encoding nodeId !
                switch (self.typeDefinitionId.toString()) {
                    case "i=7616": // EnumValueType
                    case "ns=0;i=7616": // EnumValueType
                        self.extensionObject = self.parser.Body.parser.EnumValueType.enumValueType;
                        (0, node_opcua_assert_1.assert)(self.extensionObject !== null && typeof self.extensionObject === "object");
                        (0, node_opcua_assert_1.assert)(self.extensionObject instanceof node_opcua_extension_object_1.ExtensionObject);
                        break;
                    case "i=297": // Arguments
                    case "ns=0;i=297": // Arguments
                        self.extensionObject = self.parser.Body.parser.Argument.argument;
                        (0, node_opcua_assert_1.assert)(self.extensionObject !== null && typeof self.extensionObject === "object");
                        (0, node_opcua_assert_1.assert)(self.extensionObject instanceof node_opcua_extension_object_1.ExtensionObject);
                        break;
                    case "i=888":
                    case "ns=0;i=888": // EUInformation
                        self.extensionObject = self.parser.Body.parser.EUInformation.euInformation;
                        (0, node_opcua_assert_1.assert)(self.extensionObject !== null && typeof self.extensionObject === "object");
                        (0, node_opcua_assert_1.assert)(self.extensionObject instanceof node_opcua_extension_object_1.ExtensionObject);
                        break;
                    case "i=885": // Range
                    case "ns=0;i=885":
                        self.extensionObject = self.parser.Body.parser.Range.range;
                        (0, node_opcua_assert_1.assert)(self.extensionObject !== null && typeof self.extensionObject === "object");
                        (0, node_opcua_assert_1.assert)(self.extensionObject instanceof node_opcua_extension_object_1.ExtensionObject);
                        break;
                    default: {
                        // istanbul ignore next
                        if (!this._cloneFragment) {
                            // the XML file is probably not exposing standard UA extension object correctly.
                            // this has been seen in some generated xml files using the dataType nodeId instead of the default encoding
                            // nodeid
                            errorLog("[NODE-OPCUA-E12] standard OPCUA Extension object from (namespace=0) has a invalid TypeId", self.typeDefinitionId.toString());
                            break;
                        }
                        this.bodyXML = this._cloneFragment.value;
                        this._cloneFragment.value = null;
                        // the "Default Xml" encoding  nodeId
                        const xmlEncodingNodeId = _translateNodeId(self.typeDefinitionId.toString());
                        if (xmlEncodingNodeId.isEmpty()) {
                            debugLog("xmlEncodingNodeId is empty for " + self.typeDefinitionId.toString());
                            break;
                        }
                        let captureXmlBody = this.bodyXML;
                        if (doDebug) {
                            debugLog("xxxx ", chalk.yellow(captureXmlBody));
                        }
                        // this is a user defined Extension Object
                        debugLog("load nodeset2: typeDefinitionId in ExtensionObject Default XML = " + xmlEncodingNodeId.toString());
                        let captured = self.postTaskData;
                        self.extensionObjectPojo = null;
                        const task = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
                            const extensionObject = yield (0, decode_xml_extension_object_1.decodeXmlExtensionObject)(addressSpace2, xmlEncodingNodeId, captureXmlBody);
                            if (captured) {
                                captured.postponedExtensionObject = extensionObject;
                            }
                            captureXmlBody = undefined;
                            captured = undefined;
                        });
                        postTasks0_DecodePojoString.push(task);
                        (0, node_opcua_assert_1.assert)(!self.extensionObject || self.extensionObject instanceof node_opcua_extension_object_1.ExtensionObject);
                        break;
                    }
                }
            }
        }
    };
    const extensionObject_parser = {
        ExtensionObject: {
            init() {
                this.typeDefinitionId = node_opcua_nodeid_1.NodeId.nullNodeId;
                this.extensionObject = null;
                this.extensionObjectPojo = null;
                this.postTaskData = { postponedExtensionObject: null };
            },
            parser: _extensionObject_inner_parser,
            finish() {
                /* empty */
            }
        }
    };
    function BasicType_parser(dataType, parseFunc) {
        const _parser = {};
        const r = {
            init(name, attrs) {
                this.value = undefined;
            },
            finish() {
                this.value = parseFunc.call(this, this.text);
            }
        };
        _parser[dataType] = r;
        return _parser;
    }
    function ListOf(dataType, parseFunc) {
        return {
            init() {
                this.listData = [];
            },
            parser: BasicType_parser(dataType, parseFunc),
            finish() {
                this.parent.parent.obj.value = {
                    arrayType: node_opcua_variant_1.VariantArrayType.Array,
                    dataType: node_opcua_variant_1.DataType[dataType],
                    value: this.listData
                };
            },
            endElement(element) {
                this.listData.push(this.parser[dataType].value);
            }
        };
    }
    function parser2(type, p) {
        return {
            finish() {
                this.parent.parent.obj.value = {
                    arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                    dataType: node_opcua_variant_1.DataType[type],
                    value: p(this.text)
                };
            }
        };
    }
    const parseUInt64 = (str) => (0, node_opcua_basic_types_1.coerceUInt64)(str);
    const parseInt64 = (str) => (0, node_opcua_basic_types_1.coerceInt64)(str);
    const state_Variant = {
        init: () => {
            /* empty */
        },
        parser: {
            QualifiedName: Object.assign(Object.assign({}, qualifiedName_parser.QualifiedName), { finish() {
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.QualifiedName,
                        value: this.qualifiedName
                    };
                } }),
            LocalizedText: Object.assign(Object.assign({}, localizedText_parser.LocalizedText), { finish() {
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.LocalizedText,
                        value: this.localizedText
                    };
                } }),
            XmlElement: {
                finish() {
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.XmlElement,
                        value: this.text
                    };
                }
            },
            String: {
                finish() {
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.String,
                        value: this.text
                    };
                }
            },
            Guid: {
                parser: {
                    String: {
                        finish() {
                            const guid = this.text;
                            if (!(0, node_opcua_basic_types_1.isValidGuid)(guid)) {
                                /* ?*/
                            }
                            this.parent.parent.parent.obj.value = {
                                dataType: node_opcua_variant_1.DataType.Guid,
                                arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                                value: this.text
                            };
                        }
                    }
                }
            },
            NodeId: {
                parser: {
                    Identifier: {
                        finish() {
                            const nodeId = this.text;
                            this.parent.parent.parent.obj.value = {
                                dataType: node_opcua_variant_1.DataType.NodeId,
                                arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                                value: _translateNodeId((0, node_opcua_nodeid_1.resolveNodeId)(nodeId).toString())
                            };
                        }
                    }
                }
            },
            Boolean: parser2("Boolean", ec.coerceBoolean),
            Byte: parser2("Byte", parseInt),
            Int16: parser2("Int16", parseInt),
            Int32: parser2("Int32", parseInt),
            Int8: parser2("Int8", parseInt),
            SByte: parser2("SByte", parseInt),
            UInt16: parser2("UInt16", parseInt),
            UInt32: parser2("UInt32", parseInt),
            UInt8: parser2("UInt8", parseInt),
            UInt64: parser2("UInt64", parseUInt64),
            Int64: parser2("Int64", parseInt64),
            ByteString: {
                init() {
                    this.value = null;
                },
                finish() {
                    const base64text = this.text;
                    const byteString = Buffer.from(base64text, "base64");
                    this.parent.parent.obj.value = {
                        arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                        dataType: node_opcua_variant_1.DataType.ByteString,
                        value: byteString
                    };
                }
            },
            Float: {
                finish() {
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.Float,
                        value: parseFloat(this.text)
                    };
                }
            },
            Double: {
                finish() {
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.Double,
                        value: parseFloat(this.text)
                    };
                }
            },
            ListOfExtensionObject: {
                init() {
                    this.listExtensionObject = [];
                },
                parser: extensionObject_parser,
                finish() {
                    installExtensionObjectListInitializationPostTask(this);
                },
                startElement(elementName) {
                    /* empty */
                    const extensionObjectParser = this.parser.ExtensionObject;
                    extensionObjectParser.postTaskData = { postponedExtensionObject: null };
                },
                endElement(elementName) {
                    const extensionObjectParser = this.parser.ExtensionObject;
                    this.listExtensionObject.push(extensionObjectParser.extensionObject);
                    if (this.parser.ExtensionObject.extensionObject === null) {
                        // extension object creation will be postponed
                        const index = this.listExtensionObject.length - 1;
                        let capturedData = extensionObjectParser.postTaskData;
                        // istanbul ignore next
                        if (!capturedData) {
                            throw new Error("Internal Error : postponedExtensionObject not resolved");
                        }
                        let listExtensionObject = this.listExtensionObject;
                        const task = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
                            // istanbul ignore next
                            if (!capturedData.postponedExtensionObject) {
                                throw new Error("Internal Error : postponedExtensionObject not resolved");
                            }
                            listExtensionObject[index] = capturedData.postponedExtensionObject;
                            capturedData = undefined;
                            listExtensionObject = undefined;
                        });
                        postTasks2_AssignedExtensionObjectToDataValue.push(task);
                    }
                }
            },
            ListOfLocalizedText: {
                init() {
                    this.listData = [];
                },
                parser: localizedText_parser,
                finish() {
                    this.parent.parent.obj.value = {
                        arrayType: node_opcua_variant_1.VariantArrayType.Array,
                        dataType: node_opcua_variant_1.DataType.LocalizedText,
                        value: this.listData
                    };
                },
                endElement() {
                    this.listData.push(this.parser.LocalizedText.localizedText);
                }
            },
            ListOfQualifiedName: {
                init() {
                    this.listData = [];
                },
                parser: qualifiedName_parser,
                finish() {
                    this.parent.parent.obj.value = {
                        arrayType: node_opcua_variant_1.VariantArrayType.Array,
                        dataType: node_opcua_variant_1.DataType.QualifiedName,
                        value: this.listData
                    };
                },
                endElement() {
                    this.listData.push(this.parser.QualifiedName.qualifiedName);
                }
            },
            ListOfNodeId: {
                init() {
                    this.listData = [];
                },
                parser: nodeId_parser,
                finish() {
                    this.parent.parent.obj.value = {
                        arrayType: node_opcua_variant_1.VariantArrayType.Array,
                        dataType: node_opcua_variant_1.DataType.NodeId,
                        value: this.listData
                    };
                },
                endElement(elementName) {
                    this.listData.push(this.parser.NodeId.nodeId);
                }
            },
            ListOfBoolean: ListOf("Boolean", ec.coerceBoolean),
            ListOfByte: ListOf("Byte", parseInt),
            ListOfDouble: ListOf("Double", parseFloat),
            ListOfFloat: ListOf("Float", parseFloat),
            ListOfInt32: ListOf("Int32", parseInt),
            ListOfInt16: ListOf("Int16", parseInt),
            ListOfInt8: ListOf("Int8", parseInt),
            ListOfUInt32: ListOf("UInt32", parseInt),
            ListOfUInt16: ListOf("UInt16", parseInt),
            ListOfUInt8: ListOf("UInt8", parseInt),
            ListOfString: ListOf("String", (value) => value),
            ListOfXmlElement: ListOf("XmlElement", (value) => value),
            ExtensionObject: {
                init() {
                    this.typeDefinitionId = node_opcua_nodeid_1.NodeId.nullNodeId;
                    this.extensionObject = null;
                    this.postTaskData = { postponedExtensionObject: null };
                },
                parser: _extensionObject_inner_parser,
                finish() {
                    // istanbul ignore next
                    if (this.extensionObject && !(this.extensionObject instanceof node_opcua_extension_object_1.ExtensionObject)) {
                        throw new Error("expecting an extension object");
                    }
                    this.parent.parent.obj.value = {
                        dataType: node_opcua_variant_1.DataType.ExtensionObject,
                        value: this.extensionObject
                    };
                    if (!this.extensionObject) {
                        installExtensionObjectInitializationPostTask(this);
                    }
                }
            }
        }
    };
    function installExtensionObjectListInitializationPostTask(element) {
        let listExtensionObject = element.listExtensionObject;
        let nodeId = element.parent.parent.obj.nodeId;
        (0, node_opcua_assert_1.assert)(nodeId, "expecting a nodeid");
        const task = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
            const node = addressSpace2.findNode(nodeId);
            if (!node) {
                debugLog("Cannot find node with nodeId " + nodeId + ". may be the node was marked as deprecated");
            }
            else if (node.nodeClass === node_opcua_data_model_1.NodeClass.Variable) {
                const v = node;
                (0, node_opcua_assert_1.assert)(v.getBasicDataType() === node_opcua_variant_1.DataType.ExtensionObject, "expecting an extension object");
                v.bindExtensionObject(listExtensionObject, { createMissingProp: false });
            }
            else if (node.nodeClass === node_opcua_data_model_1.NodeClass.VariableType) {
                // no need to bind a variable type
                const v = node;
                v /*fix me*/.value.value = listExtensionObject;
            }
            listExtensionObject.slice(0);
            listExtensionObject = undefined;
            nodeId = undefined;
        });
        postTasks2_AssignedExtensionObjectToDataValue.push(task);
    }
    function installExtensionObjectInitializationPostTask(element) {
        // let's create the mechanism that postpone the creation of the
        // extension object
        let data = element.postTaskData;
        let variant = element.parent.parent.obj.value;
        let nodeId = element.parent.parent.obj.nodeId;
        const task = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
            variant.value = data.postponedExtensionObject;
            (0, node_opcua_assert_1.assert)(nodeId, "expecting a nodeid");
            const node = addressSpace2.findNode(nodeId);
            if (node.nodeClass === node_opcua_data_model_1.NodeClass.Variable) {
                const v = node;
                (0, node_opcua_assert_1.assert)(v.getBasicDataType() === node_opcua_variant_1.DataType.ExtensionObject, "expecting an extension object");
                v.bindExtensionObject(variant.value, { createMissingProp: false });
            }
            else if (node.nodeClass === node_opcua_data_model_1.NodeClass.VariableType) {
                const v = node;
                v /*fix me*/.value.value = variant.value;
            }
            data.postponedExtensionObject = null;
            data = undefined;
            variant = undefined;
            nodeId = undefined;
        });
        postTasks2_AssignedExtensionObjectToDataValue.push(task);
    }
    const canIngore = ({ isDraft, isDeprecated }, node) => {
        if (isDraft && !options.loadDraftNodes) {
            debugLog("Ignoring Draft            =", node_opcua_data_model_1.NodeClass[node.nodeClass], node.browseName.toString());
            return true;
        }
        if (isDeprecated && !options.loadDeprecatedNodes) {
            debugLog("Ignoring Deprecate        =", node_opcua_data_model_1.NodeClass[node.nodeClass], node.browseName.toString());
            return true;
        }
        return false;
    };
    const state_UAVariable = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.Variable;
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
            this.obj.parentNodeId = convertToNodeId(attrs.ParentNodeId);
            this.obj.dataType = convertToNodeId(attrs.DataType);
            this.obj.valueRank = attrs.ValueRank === undefined ? -1 : ec.coerceInt32(attrs.ValueRank);
            this.obj.arrayDimensions = this.obj.valueRank <= 0 ? null : stringToUInt32Array(attrs.ArrayDimensions);
            this.obj.minimumSamplingInterval = attrs.MinimumSamplingInterval ? parseInt(attrs.MinimumSamplingInterval, 10) : 0;
            this.obj.minimumSamplingInterval = parseInt(this.obj.minimumSamplingInterval, 10);
            this.obj.historizing = false;
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.obj.accessLevel = convertAccessLevel(attrs.AccessLevel);
            this.obj.userAccessLevel = this.obj.accessLevel; // convertAccessLevel(attrs.UserAccessLevel || attrs.AccessLevel);
            this.isDraft = attrs.ReleaseStatus === "Draft";
            this.isDeprecated = attrs.ReleaseStatus === "Deprecated";
        },
        finish() {
            if (canIngore({ isDraft: this.isDraft, isDeprecated: this.isDeprecated }, this.obj)) {
                return;
            }
            /*
            // set default value based on obj data Type
            if (this.obj.value === undefined) {
                const dataTypeNode = this.obj.dataType;
                const valueRank = this.obj.valueRank;
                this.obj.value = makeDefaultVariant(addressSpace, dataTypeNode, valueRank);
            }
            */
            // eslint-disable-next-line prefer-const
            let capturedVariable;
            if (this.obj.value) {
                let capturedValue = this.obj.value;
                const task = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
                    if (false && doDebug) {
                        debugLog("1 setting value to ", capturedVariable.nodeId.toString(), new node_opcua_variant_1.Variant(capturedValue).toString());
                    }
                    capturedVariable.setValueFromSource(capturedValue);
                    capturedValue = undefined;
                    capturedVariable = undefined;
                });
                if (capturedValue.dataType !== node_opcua_variant_1.DataType.ExtensionObject) {
                    postTasks0_InitializeVariable.push(task);
                }
                else {
                    // do them later
                    postTasks1_InitializeVariable.push(task);
                }
            }
            else {
                const task = (addressSpace2) => __awaiter(this, void 0, void 0, function* () {
                    const dataTypeNode = capturedVariable.dataType;
                    const valueRank = capturedVariable.valueRank;
                    const value = makeDefaultVariant(addressSpace, dataTypeNode, valueRank);
                    if (value) {
                        if (false && doDebug) {
                            debugLog("2 setting value to ", capturedVariable.nodeId.toString(), value);
                        }
                        if (value.dataType === node_opcua_variant_1.DataType.Null) {
                            capturedVariable.setValueFromSource(value, node_opcua_basic_types_1.StatusCodes.BadWaitingForInitialData);
                        }
                        else {
                            capturedVariable.setValueFromSource(value, node_opcua_basic_types_1.StatusCodes.Good);
                        }
                    }
                    capturedVariable = undefined;
                });
                postTasks0_InitializeVariable.push(task);
            }
            this.obj.value = undefined;
            capturedVariable = _internal_createNode(this.obj);
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            Description: {
                finish() {
                    this.parent.obj.description = this.text;
                }
            },
            References: references_parser,
            Value: state_Variant
        }
    };
    const state_UAVariableType = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.isAbstract = ec.coerceBoolean(attrs.IsAbstract);
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.VariableType;
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
            this.obj.parentNodeId = attrs.ParentNodeId || null;
            this.obj.dataType = convertToNodeId(attrs.DataType) || null;
            this.obj.valueRank = ec.coerceInt32(attrs.ValueRank) || -1;
            this.obj.arrayDimensions = this.obj.valueRank <= 0 ? null : stringToUInt32Array(attrs.ArrayDimensions);
            this.obj.minimumSamplingInterval = attrs.MinimumSamplingInterval ? parseInt(attrs.MinimumSamplingInterval, 10) : 0;
            this.obj.historizing = false;
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.isDraft = attrs.ReleaseStatus === "Draft";
            this.isDeprecated = attrs.ReleaseStatus === "Deprecated";
        },
        finish() {
            if (canIngore({ isDraft: this.isDraft, isDeprecated: this.isDeprecated }, this.obj)) {
                return;
            }
            try {
                _internal_createNode(this.obj);
            } /* istanbul ignore next */
            catch (err) {
                this.obj.addressSpace = null;
                // tslint:disable:no-console
                console.warn(" Cannot create object", JSON.stringify(this.obj, null, " "));
                throw err;
            }
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            Description: {
                finish() {
                    this.parent.obj.description = this.text;
                }
            },
            References: references_parser,
            Value: state_Variant
        }
    };
    const state_UAMethod = {
        init(name, attrs) {
            _perform();
            this.obj = {};
            this.obj.nodeClass = node_opcua_data_model_1.NodeClass.Method;
            // MethodDeclarationId
            // ParentNodeId
            this.obj.browseName = convertQualifiedName(attrs.BrowseName);
            this.obj.parentNodeId = attrs.ParentNodeId || null;
            this.obj.nodeId = convertToNodeId(attrs.NodeId) || null;
            this.obj.methodDeclarationId = attrs.MethodDeclarationId ? _translateNodeId(attrs.MethodDeclarationId) : null;
            this.isDraft = attrs.ReleaseStatus === "Draft";
            this.isDeprecated = attrs.ReleaseStatus === "Deprecated";
        },
        finish() {
            if (canIngore({ isDraft: this.isDraft, isDeprecated: this.isDeprecated }, this.obj)) {
                return;
            }
            _internal_createNode(this.obj);
        },
        parser: {
            DisplayName: {
                finish() {
                    this.parent.obj.displayName = this.text;
                }
            },
            References: references_parser
        }
    };
    const state_ModelTableEntry = new node_opcua_xml2json_1.ReaderState({
        // ModelTableEntry
        init() {
            this._requiredModels = [];
        },
        parser: {
            RequiredModel: {
                init(name, attrs) {
                    const modelUri = attrs.ModelUri;
                    const version = attrs.Version;
                    const publicationDate = new Date(Date.parse(attrs.PublicationDate));
                    this.parent._requiredModels.push({ modelUri, version, publicationDate });
                },
                finish() {
                    /** */
                }
            }
        },
        finish() {
            const modelUri = this.attrs.ModelUri; // //"http://opcfoundation.org/UA/"
            const version = this.attrs.Version; // 1.04
            const publicationDate = this.attrs.PublicationDate ? new Date(Date.parse(this.attrs.PublicationDate)) : undefined; // "2018-05-15T00:00:00Z" "
            // optional,
            const symbolicName = this.attrs.SymbolicName;
            const accessRestrictions = this.attrs.AccessRestrictions;
            const model = {
                accessRestrictions,
                modelUri,
                publicationDate,
                requiredModels: this._requiredModels,
                symbolicName,
                version
            };
            const namespace = _add_namespace(model);
            models.push(model);
        }
    });
    function _updateTranslationTable() {
        _register_namespace_uri_in_translation_table("http://opcfoundation.org/UA/");
        for (const namespaceUri of _namespaceUris) {
            _register_namespace_uri_in_translation_table(namespaceUri);
        }
    }
    function _perform() {
        if (performedCalled)
            return;
        performedCalled = true;
        /**special case for old nodeset file version 1.02 where no models exists */
        if (models.length === 0) {
            for (const namespaceuri of _namespaceUris) {
                const existingNamespace = addressSpace1.getNamespace(namespaceuri);
                if (existingNamespace) {
                    continue;
                }
                _add_namespace({
                    modelUri: namespaceuri,
                    version: "1.0.0",
                    requiredModels: []
                });
            }
        }
        _updateTranslationTable();
    }
    // state_ModelTableEntry.parser["RequiredModel"] = state_ModelTableEntry;
    let _namespaceUris = [];
    const state_0 = {
        parser: {
            Aliases: {
                init() {
                    _perform();
                },
                parser: { Alias: state_Alias }
            },
            NamespaceUris: {
                init() {
                    //
                    _namespaceUris = [];
                },
                parser: {
                    Uri: {
                        finish() {
                            _namespaceUris.push(this.text);
                        }
                    }
                },
                finish() {
                    // verify that requested namespaces are already loaded or abort with a message
                }
            },
            Models: {
                // ModelTable
                init(name, attrs) {
                    /* */
                },
                parser: {
                    Model: state_ModelTableEntry
                },
                finish() {
                    /** */
                }
            },
            UADataType: state_UADataType,
            UAMethod: state_UAMethod,
            UAObject: state_UAObject,
            UAObjectType: state_UAObjectType,
            UAReferenceType: state_UAReferenceType,
            UAVariable: state_UAVariable,
            UAVariableType: state_UAVariableType
        }
    };
    const parser = new node_opcua_xml2json_1.Xml2Json(state_0);
    function terminate(callback) {
        var _a, _b, _c;
        make_back_references(addressSpace1);
        // setting up Server_NamespaceArray
        if ((_c = (_b = (_a = addressSpace1.rootFolder) === null || _a === void 0 ? void 0 : _a.objects) === null || _b === void 0 ? void 0 : _b.server) === null || _c === void 0 ? void 0 : _c.namespaceArray) {
            addressSpace1.rootFolder.objects.server.namespaceArray.setValueFromSource({
                arrayType: node_opcua_variant_1.VariantArrayType.Array,
                dataType: node_opcua_variant_1.DataType.String,
                value: addressSpace1.getNamespaceArray().map((ns) => ns.namespaceUri)
            });
            // istanbul ignore next
            if (doDebug) {
                debugLog("addressSpace NS = ", addressSpace1.rootFolder.objects.server.namespaceArray.readValue().value.value.join(" "));
            }
        }
        doDebug &&
            debugLog(chalk.bgGreenBright("Performing post loading tasks -------------------------------------------") +
                chalk.green("DONE"));
        function performPostLoadingTasks(tasks) {
            return __awaiter(this, void 0, void 0, function* () {
                for (const task of tasks) {
                    try {
                        yield task(addressSpace1);
                    }
                    catch (err) {
                        // istanbul ignore next
                        // tslint:disable:no-console
                        if (util_1.types.isNativeError(err)) {
                            console.log(" performPostLoadingTasks Err  => ", err.message, "\n", err);
                        }
                        yield task(addressSpace1);
                    }
                }
                tasks.splice(0);
            });
        }
        function finalSteps() {
            return __awaiter(this, void 0, void 0, function* () {
                /// ----------------------------------------------------------------------------------------
                // perform post task
                doDebug && debugLog(chalk.bgGreenBright("Performing post loading tasks -------------------------------------------"));
                yield performPostLoadingTasks(postTasks);
                doDebug &&
                    debugLog(chalk.bgGreenBright("Performing post loading task: Initializing Simple Variables ---------------------"));
                yield performPostLoadingTasks(postTasks0_InitializeVariable);
                doDebug && debugLog(chalk.bgGreenBright("Performing DataType extraction -------------------------------------------"));
                (0, node_opcua_assert_1.assert)(!addressSpace1.suspendBackReference);
                yield (0, ensure_datatype_extracted_1.ensureDatatypeExtracted)(addressSpace);
                const dataTypeManager = addressSpace.getDataTypeManager();
                /// ----------------------------------------------------------------------------------------
                doDebug && debugLog(chalk.bgGreenBright("DataType extraction done ") + chalk.green("DONE"));
                for (const { name, dataTypeNodeId } of pendingSimpleTypeToRegister) {
                    if (dataTypeNodeId.namespace === 0) {
                        continue;
                    }
                    const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(dataTypeNodeId.namespace);
                }
                pendingSimpleTypeToRegister.splice(0);
                doDebug && debugLog(chalk.bgGreenBright("Performing post loading task: Decoding Pojo String (parsing XML objects) -"));
                yield performPostLoadingTasks(postTasks0_DecodePojoString);
                doDebug &&
                    debugLog(chalk.bgGreenBright("Performing post loading task: Initializing Complex Variables ---------------------"));
                yield performPostLoadingTasks(postTasks1_InitializeVariable);
                doDebug && debugLog(chalk.bgGreenBright("Performing post loading tasks: (assigning Extension Object to Variables) -"));
                yield performPostLoadingTasks(postTasks2_AssignedExtensionObjectToDataValue);
                doDebug && debugLog(chalk.bgGreenBright("Performing post variable initialization ---------------------"));
                (0, namespace_post_step_1.promoteObjectsAndVariables)(addressSpace);
            });
        }
        finalSteps()
            .then(() => callback())
            .catch((err1) => {
            console.log("Error ", (0, node_opcua_assert_1.renderError)(err1));
            callback(err1);
        });
    }
    function addNodeSet(xmlData, callback1) {
        _reset_namespace_translation();
        parser.parseString(xmlData, callback1);
    }
    return {
        addNodeSet,
        terminate
    };
}
class NodeSetLoader {
    constructor(addressSpace, options) {
        this.options = options;
        this._s = makeNodeSetParserEngine(addressSpace, options || {});
    }
    addNodeSet(xmlData, callback) {
        if (!callback) {
            throw new Error("Expecting callback function");
        }
        return this._s.addNodeSet(xmlData, callback);
    }
    addNodeSetAsync(xmlData) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, util_1.promisify)(this.addNodeSet).call(this, xmlData);
        });
    }
    terminate(callback) {
        this._s.terminate(callback);
    }
    terminateAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, util_1.promisify)(this.terminate).call(this);
        });
    }
}
exports.NodeSetLoader = NodeSetLoader;
//# sourceMappingURL=load_nodeset2.js.map