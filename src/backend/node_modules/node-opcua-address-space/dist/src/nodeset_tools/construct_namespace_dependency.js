"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructNamespaceDependency = exports.constructNamespacePriorityTable = exports.hasHigherPriorityThan = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const base_node_impl_1 = require("../base_node_impl");
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
function _constructNamespaceDependency(namespace, dependency, depMap, _visitedDataType, priorityTable) {
    const addressSpace = namespace.addressSpace;
    const namespace_ = namespace;
    // navigate all namespace recursively to
    function consider(namespaceIndex) {
        if (hasHigherPriorityThan(namespaceIndex, namespace.index, priorityTable)) {
            return;
        }
        if (!depMap.has(namespaceIndex)) {
            depMap.add(namespaceIndex);
            const namespace = addressSpace.getNamespace(namespaceIndex);
            dependency.push(namespace);
            if (namespaceIndex > 0) {
                _constructNamespaceDependency(namespace, dependency, depMap, _visitedDataType, priorityTable);
            }
        }
    }
    function exploreDataTypeField(field) {
        const dataType = field.dataType;
        const namespaceIndex = dataType.namespace;
        consider(namespaceIndex);
        const dataTypeNode = addressSpace.findDataType(field.dataType);
        if (dataTypeNode) {
            exploreDataTypes(dataTypeNode);
        }
    }
    function exploreDataTypes(dataTypeNode) {
        const dataType = dataTypeNode.nodeId;
        if (_visitedDataType.has(dataType.toString())) {
            return;
        }
        // istanbul ignore next
        if (dataTypeNode.nodeClass !== node_opcua_data_model_1.NodeClass.DataType) {
            warningLog("exploreDataTypes! ignoring ", dataTypeNode.toString());
            return;
        }
        const namespaceIndex = dataType.namespace;
        consider(namespaceIndex);
        if (dataTypeNode.isStructure()) {
            const definition = dataTypeNode.getStructureDefinition();
            for (const field of definition.fields || []) {
                exploreDataTypeField(field);
            }
        }
        _visitedDataType.add(dataType.toString());
    }
    for (const node of namespace_.nodeIterator()) {
        if (node.nodeClass === node_opcua_data_model_1.NodeClass.Variable || node.nodeClass === node_opcua_data_model_1.NodeClass.VariableType) {
            const dataTypeNodeId = node.dataType;
            const dataTypeNode = addressSpace.findDataType(dataTypeNodeId);
            if (dataTypeNode) {
                exploreDataTypes(dataTypeNode);
            }
            else {
                // istanbul ignore next
                if (dataTypeNodeId.value != 0) {
                    console.log("Internal error: Cannot find dataType", dataTypeNodeId.toString());
                }
            }
        }
        // visit all references
        const references = node.ownReferences();
        for (const reference of references) {
            // check referenceId
            const namespaceIndex = (0, base_node_impl_1.getReferenceType)(reference).nodeId.namespace;
            consider(namespaceIndex);
            const namespaceIndex2 = reference.nodeId.namespace;
            consider(namespaceIndex2);
        }
    }
}
function hasHigherPriorityThan(namespaceIndex1, namespaceIndex2, priorityTable) {
    const order1 = priorityTable[namespaceIndex1];
    const order2 = priorityTable[namespaceIndex2];
    return order1 > order2;
}
exports.hasHigherPriorityThan = hasHigherPriorityThan;
/**
 *
 * @param namespace
 * @returns the order
 *
 *      ---
 *  ua, own , di  => 0 , 2,  1
 *
 *      ---
 *  ua, own , di , kitchen , own2,  adi  => 0 , 2,  3, 1
 *
 *                           ---
 *  ua, own , di , kitchen , own2,  adi  => 0 , 2,  3,  5, 1
 */
function constructNamespacePriorityTable(namespace) {
    // Namespace 0 will always be 0 
    // Namespaces with no requiredModel will be considered as instance namespaces and will added at the end
    // in the same order as they appear,
    // Namespace with requiredModels are considered to be companion specification, so already loaded in the correct order
    const addressSpace = namespace.addressSpace;
    const namespaces = addressSpace.getNamespaceArray();
    const namespaceWithReq = namespaces.filter((n) => (n.getRequiredModels() !== undefined) && n.index !== 0);
    const namespaceWithoutReq = namespaces.filter((n) => (n.getRequiredModels() === undefined) && n.index !== 0);
    const priorityList = [0];
    let counter = 1;
    for (let i = 0; i < namespaceWithReq.length; i++) {
        priorityList[namespaceWithReq[i].index] = counter++;
    }
    for (let i = 0; i < namespaceWithoutReq.length; i++) {
        priorityList[namespaceWithoutReq[i].index] = counter++;
    }
    return priorityList;
}
exports.constructNamespacePriorityTable = constructNamespacePriorityTable;
const doDebug = false;
function constructNamespaceDependency(namespace, priorityTable) {
    const addressSpace = namespace.addressSpace;
    priorityTable = priorityTable || constructNamespacePriorityTable(namespace);
    const dependency = [];
    const depMap = new Set();
    dependency.push(addressSpace.getDefaultNamespace());
    depMap.add(0);
    if (namespace !== addressSpace.getDefaultNamespace()) {
        dependency.push(namespace);
        depMap.add(namespace.index);
    }
    const _visitedDataType = new Set();
    _constructNamespaceDependency(namespace, dependency, depMap, _visitedDataType, priorityTable);
    doDebug && console.log("namespace : ", namespace.index, namespace.namespaceUri);
    doDebug && console.log("   ", dependency.map((d) => d.index + " " + d.namespaceUri).join("\n   "));
    const sorted = dependency.sort((a, b) => priorityTable[a.index] < priorityTable[b.index] ? -1 : 1);
    doDebug && console.log("sorted:");
    doDebug && console.log("   ", sorted.map((d) => d.index + " " + d.namespaceUri).join("\n   "));
    return sorted;
}
exports.constructNamespaceDependency = constructNamespaceDependency;
//# sourceMappingURL=construct_namespace_dependency.js.map