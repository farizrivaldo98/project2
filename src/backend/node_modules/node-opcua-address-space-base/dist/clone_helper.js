"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructFunctionalGroupType = exports.reconstructNonHierarchicalReferences = exports.CloneHelper = void 0;
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_constants_1 = require("node-opcua-constants");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("CLONE");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("CLONE");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("CLONE");
//
//  case 1:
//   /-----------------------------\
//   | AcknowledgeableConditionType |
//   \-----------------------------/
//              ^        |
//              |        +---------------------|- (EnabledState)   (shadow element)
//              |
//   /-----------------------------\
//   |        AlarmConditionType   |
//   \-----------------------------/
//              |
//              +-------------------------------|- EnabledState    <
//
// find also child object with the same browse name that are
// overridden in the SuperType
// case 2:
//
//   /-----------------------------\
//   | MyDeviceType               |
//   \-----------------------------/
//              ^        |
//              |        |       +----------+
//              |        +-------| Folder1  |
//              |                +----------+
//              |                     |
//              |                     +--------------|- (EnabledState)   (shadow element)
//              |
//   /-----------------------------\
//   | MyDeriveDeviceType   |
//   \-----------------------------/
//              |
//              |        |       +----------+
//              |        +-------| Folder1  |
//              |                +----------+
//              |                     |
//              |                     +--------------|- (EnabledState)
//
// find also child object with the same browse name that are
function _get_parent_type_and_path(originalObject) {
    if (originalObject.nodeClass === node_opcua_data_model_1.NodeClass.Method) {
        return { parentType: null, path: [] };
    }
    const addressSpace = originalObject.addressSpace;
    const parents = originalObject.findReferencesEx("HasChild", node_opcua_data_model_1.BrowseDirection.Inverse);
    // istanbul ignore next
    if (parents.length > 1) {
        warningLog(" object ", originalObject.browseName.toString(), " has more than one parent !");
        warningLog(originalObject.toString());
        warningLog(" parents : ");
        for (const parent of parents) {
            warningLog("     ", parent.toString(), addressSpace.findNode(parent.nodeId).browseName.toString());
        }
        return { parentType: null, path: [] };
    }
    (0, node_opcua_assert_1.assert)(parents.length === 0 || parents.length === 1);
    if (parents.length === 0) {
        return { parentType: null, path: [] };
    }
    const theParent = addressSpace.findNode(parents[0].nodeId);
    if (theParent && (theParent.nodeClass === node_opcua_data_model_1.NodeClass.VariableType || theParent.nodeClass === node_opcua_data_model_1.NodeClass.ObjectType)) {
        return { parentType: theParent, path: [originalObject.browseName] };
    }
    // walk up
    const { parentType, path } = _get_parent_type_and_path(theParent);
    return { parentType, path: [...path, originalObject.browseName] };
}
function followPath(node, path) {
    let current = node;
    for (const qn of path) {
        const ref = current
            .findReferencesExAsObject("HierarchicalReferences", node_opcua_data_model_1.BrowseDirection.Forward)
            .find((r) => r.browseName.toString() === qn.toString());
        if (!ref) {
            return null;
        }
        current = ref;
    }
    return current;
}
class CloneHelper {
    constructor() {
        this.level = 0;
        this.mapOrgToClone = new Map();
    }
    pad() {
        return " ".padEnd(this.level * 2, " ");
    }
    registerClonedObject(clonedNode, originalNode) {
        this.mapOrgToClone.set(originalNode.nodeId.toString(), {
            cloned: clonedNode,
            original: originalNode
        });
        //
        const { parentType, path } = _get_parent_type_and_path(originalNode);
        if (parentType) {
            let base = parentType.subtypeOfObj;
            while (base) {
                const shadowChild = followPath(base, path);
                if (shadowChild) {
                    this.mapOrgToClone.set(shadowChild.nodeId.toString(), {
                        cloned: clonedNode,
                        original: shadowChild
                    });
                }
                base = base.subtypeOfObj;
            }
        }
        else {
        }
        // find subTypeOf
    }
    getCloned(originalNode) {
        const info = this.mapOrgToClone.get(originalNode.nodeId.toString());
        if (info) {
            return info.cloned;
        }
        return null;
    }
}
exports.CloneHelper = CloneHelper;
const hasTypeDefinitionNodeId = (0, node_opcua_nodeid_1.makeNodeId)(node_opcua_constants_1.ReferenceTypeIds.HasTypeDefinition);
const hasModellingRuleNodeId = (0, node_opcua_nodeid_1.makeNodeId)(node_opcua_constants_1.ReferenceTypeIds.HasModellingRule);
/**
 * remove unwanted reference such as HasTypeDefinition and HasModellingRule
 * from the list
 */
function _remove_unwanted_ref(references) {
    // filter out HasTypeDefinition (i=40) , HasModellingRule (i=37);
    references = references.filter((reference) => !(0, node_opcua_nodeid_1.sameNodeId)(reference.referenceType, hasTypeDefinitionNodeId) &&
        !(0, node_opcua_nodeid_1.sameNodeId)(reference.referenceType, hasModellingRuleNodeId));
    return references;
}
/**
 *
 */
function findNonHierarchicalReferences(originalObject) {
    // todo: MEMOIZE this method
    const addressSpace = originalObject.addressSpace;
    // we need to explore the non hierarchical references backwards
    let references = originalObject.findReferencesEx("NonHierarchicalReferences", node_opcua_data_model_1.BrowseDirection.Inverse);
    references = [].concat(references, originalObject.findReferencesEx("HasEventSource", node_opcua_data_model_1.BrowseDirection.Inverse));
    const { parentType, path } = _get_parent_type_and_path(originalObject);
    if (parentType && parentType.subtypeOfObj) {
        // parent is a ObjectType or VariableType and is not a root type
        (0, node_opcua_assert_1.assert)(parentType.nodeClass === node_opcua_data_model_1.NodeClass.VariableType || parentType.nodeClass === node_opcua_data_model_1.NodeClass.ObjectType);
        // let investigate the same child base child
        const child = followPath(parentType.subtypeOfObj, path);
        if (child) {
            const baseRef = findNonHierarchicalReferences(child);
            references = [].concat(references, baseRef);
        }
    }
    // perform some cleanup
    references = _remove_unwanted_ref(references);
    return references;
}
function reconstructNonHierarchicalReferences(extraInfo) {
    const extraInfo_ = extraInfo;
    const findImplementedObject = (ref) => extraInfo_.mapOrgToClone.get(ref.nodeId.toString()) || null;
    // navigate through original objects to find those that are being references by node that
    // have been cloned .
    // this could be node organized by some FunctionalGroup
    for (const { original, cloned } of extraInfo_.mapOrgToClone.values()) {
        apply(original, cloned);
    }
    function apply(original, cloned) {
        const addressSpace = original.addressSpace;
        // find NonHierarchical References on original object
        const originalNonHierarchical = findNonHierarchicalReferences(original);
        if (originalNonHierarchical.length === 0) {
            return;
        }
        // istanbul ignore next
        if (doDebug) {
            debugLog(" investigation ", original.browseName.toString(), cloned.nodeClass.toString(), original.nodeClass.toString(), original.nodeId.toString(), cloned.nodeId.toString());
        }
        for (const ref of originalNonHierarchical) {
            const info = findImplementedObject(ref);
            // if the object pointed by this reference is also cloned ...
            if (info) {
                const originalDest = info.original;
                const cloneDest = info.cloned;
                // istanbul ignore next
                if (doDebug) {
                    debugLog("   adding reference ", ref.referenceType, addressSpace.findNode(ref.referenceType).browseName.toString(), " from cloned ", cloned.nodeId.toString(), cloned.browseName.toString(), " to cloned ", cloneDest.nodeId.toString(), cloneDest.browseName.toString());
                }
                // restore reference
                cloned.addReference({
                    isForward: false,
                    nodeId: cloneDest.nodeId,
                    referenceType: ref.referenceType
                });
            }
            else {
                //     // restore reference
                //     cloned.addReference({
                //         isForward: false,
                //         nodeId: ref.nodeId,
                //         referenceType: ref.referenceType
                //     });
            }
        }
    }
}
exports.reconstructNonHierarchicalReferences = reconstructNonHierarchicalReferences;
/**
 * recreate functional group types according to type definition
 *
 * @method reconstructFunctionalGroupType
 * @param baseType
 */
/* @example:
 *
 *    MyDeviceType
 *        |
 *        +----------|- ParameterSet(BaseObjectType)
 *        |                   |
 *        |                   +-----------------|- Parameter1
 *        |                                             ^
 *        +----------|- Config(FunctionalGroupType)     |
 *                                |                     |
 *                                +-------- Organizes---+
 */
function reconstructFunctionalGroupType(extraInfo) {
    const extraInfo_ = extraInfo;
    // navigate through original objects to find those that are being organized by some FunctionalGroup
    for (const { original, cloned } of extraInfo_.mapOrgToClone.values()) {
        const organizedByArray = original.findReferencesEx("Organizes", node_opcua_data_model_1.BrowseDirection.Inverse);
        for (const ref of organizedByArray) {
            const info = extraInfo_.mapOrgToClone.get(ref.nodeId.toString());
            if (!info)
                continue;
            const folder = info.original;
            if (folder.nodeClass !== node_opcua_data_model_1.NodeClass.Object)
                continue;
            if (!folder.typeDefinitionObj)
                continue;
            (0, node_opcua_assert_1.assert)(folder.typeDefinitionObj.browseName.name.toString() === "FunctionalGroupType");
            // now create the same reference with the instantiated function group
            const destFolder = info.cloned;
            (0, node_opcua_assert_1.assert)(ref.referenceType);
            // may be we should check that the referenceType is a subtype of Organizes
            const alreadyExist = destFolder
                .findReferences(ref.referenceType, !ref.isForward)
                .find((r) => r.nodeId === cloned.nodeId);
            if (alreadyExist) {
                continue;
            }
            destFolder.addReference({
                isForward: !ref.isForward,
                nodeId: cloned.nodeId,
                referenceType: ref.referenceType
            });
        }
    }
}
exports.reconstructFunctionalGroupType = reconstructFunctionalGroupType;
//# sourceMappingURL=clone_helper.js.map