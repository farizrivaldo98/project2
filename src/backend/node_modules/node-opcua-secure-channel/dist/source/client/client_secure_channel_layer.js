"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientSecureChannelLayer = exports.coerceConnectionStrategy = exports.requestHandleNotSetValue = void 0;
/**
 * @module node-opcua-secure-channel
 */
// tslint:disable:variable-name
// tslint:disable:object-literal-shorthand
// tslint:disable:no-console
const crypto_1 = require("crypto");
const events_1 = require("events");
const chalk = require("chalk");
const async = require("async");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_binary_stream_1 = require("node-opcua-binary-stream");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_opcua_chunkmanager_1 = require("node-opcua-chunkmanager");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_service_secure_channel_1 = require("node-opcua-service-secure-channel");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_transport_1 = require("node-opcua-transport");
const node_opcua_transport_2 = require("node-opcua-transport");
const message_builder_1 = require("../message_builder");
const message_chunker_1 = require("../message_chunker");
const message_header_to_string_1 = require("../message_header_to_string");
const security_policy_1 = require("../security_policy");
const services_1 = require("../services");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
const checkChunks = doDebug && false;
const doDebug1 = false;
// set checkTimeout to true to enable timeout trace checking
const checkTimeout = !!process.env.NODEOPCUACHECKTIMEOUT || false;
const common_1 = require("../common");
const utils_1 = require("../utils");
const util_1 = require("util");
// import * as backoff from "backoff";
// tslint:disable-next-line: no-var-requires
const backoff = require("backoff");
exports.requestHandleNotSetValue = 0xdeadbeef;
function process_request_callback(requestData, err, response) {
    (0, node_opcua_assert_1.assert)(typeof requestData.callback === "function");
    const request = requestData.request;
    if (!response && !err && requestData.msgType !== "CLO") {
        // this case happens when CLO is called and when some pending transactions
        // remains in the queue...
        err = new Error(" Connection has been closed by client , but this transaction cannot be honored");
    }
    if (response && response instanceof services_1.ServiceFault) {
        response.responseHeader.stringTable = [...(response.responseHeader.stringTable || [])];
        err = new Error(" serviceResult = " + response.responseHeader.serviceResult.toString());
        //  "  returned by server \n response:" + response.toString() + "\n  request: " + request.toString());
        err.response = response;
        err.request = request;
        response = undefined;
    }
    const theCallbackFunction = requestData.callback;
    /* istanbul ignore next */
    if (!theCallbackFunction) {
        throw new Error("Internal error");
    }
    (0, node_opcua_assert_1.assert)(requestData.msgType === "CLO" || (err && !response) || (!err && response));
    // let set callback to undefined to prevent callback to be called again
    requestData.callback = undefined;
    theCallbackFunction(err || null, !err && response !== null ? response : undefined);
}
function coerceConnectionStrategy(options) {
    options = options || {};
    const maxRetry = options.maxRetry === undefined ? 10 : options.maxRetry;
    const initialDelay = options.initialDelay || 10;
    const maxDelay = options.maxDelay || 10000;
    const randomisationFactor = options.randomisationFactor === undefined ? 0 : options.randomisationFactor;
    return {
        initialDelay,
        maxDelay,
        maxRetry,
        randomisationFactor
    };
}
exports.coerceConnectionStrategy = coerceConnectionStrategy;
/**
 * a ClientSecureChannelLayer represents the client side of the OPCUA secure channel.
 */
class ClientSecureChannelLayer extends events_1.EventEmitter {
    /**
     * true if the secure channel is trying to establish the connection with the server. In this case, the client
     * may be in the middle of the backoff connection process.
     *
     */
    get isConnecting() {
        return !!this.__call;
    }
    get bytesRead() {
        return this._bytesRead + (this._transport ? this._transport.bytesRead : 0);
    }
    get bytesWritten() {
        return this._bytesWritten + (this._transport ? this._transport.bytesWritten : 0);
    }
    get transactionsPerformed() {
        return this._lastRequestId;
    }
    get timedOutRequestCount() {
        return this._timeout_request_count;
    }
    constructor(options) {
        super();
        this._counter = ClientSecureChannelLayer.g_counter++;
        this._bytesRead = 0;
        this._bytesWritten = 0;
        this._tick2 = 0;
        this._isDisconnecting = false;
        this.securityHeader = null;
        this.receiverCertificate = null;
        this.securityToken = null;
        this.serverNonce = null;
        this.derivedKeys = null;
        this.receiverPublicKey = null;
        this.endpointUrl = "";
        if (global.hasResourceLeakDetector && !global.ResourceLeakDetectorStarted) {
            throw new Error("ClientSecureChannelLayer not in ResourceLeakDetectorStarted");
        }
        (0, node_opcua_assert_1.assert)(this instanceof ClientSecureChannelLayer);
        this._isOpened = false;
        this._transport = undefined;
        this._lastRequestId = 0;
        this.parent = options.parent;
        this.clientNonce = null; // will be created when needed
        this.protocolVersion = 0;
        this.messageChunker = new message_chunker_1.MessageChunker({
            derivedKeys: null
            // note maxMessageSize cannot be set at this stage, transport is not known
        });
        this.defaultSecureTokenLifetime = options.defaultSecureTokenLifetime || 30000;
        this.tokenRenewalInterval = options.tokenRenewalInterval || 0;
        this.securityMode = (0, node_opcua_service_secure_channel_1.coerceMessageSecurityMode)(options.securityMode);
        this.securityPolicy = (0, security_policy_1.coerceSecurityPolicy)(options.securityPolicy);
        this.serverCertificate = (0, common_1.extractFirstCertificateInChain)(options.serverCertificate);
        if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            (0, node_opcua_assert_1.assert)(this.serverCertificate instanceof Buffer, "Expecting a valid certificate when security mode is not None");
            (0, node_opcua_assert_1.assert)(this.securityPolicy !== security_policy_1.SecurityPolicy.None, "Security Policy None is not a valid choice");
            // make sure that we do not have a chain here ...
        }
        this._requests = {};
        this.__in_normal_close_operation = false;
        this._timeout_request_count = 0;
        this._securityTokenTimeoutId = null;
        this.transportTimeout = options.transportTimeout || ClientSecureChannelLayer.defaultTransportTimeout;
        this.requestedTransportSettings = options.transportSettings || {};
        this.channelId = 0;
        this.connectionStrategy = coerceConnectionStrategy(options.connectionStrategy);
    }
    getTransportSettings() {
        const { maxMessageSize } = this._transport ? this._transport.getTransportSettings() : { maxMessageSize: 2048 };
        return { maxMessageSize: maxMessageSize || 0 };
    }
    _install_message_builder() {
        // istanbul ignore next
        if (!this._transport || !this._transport.parameters) {
            throw new Error("internal error");
        }
        this.messageBuilder = new message_builder_1.MessageBuilder({
            name: "client",
            privateKey: this.getPrivateKey() || undefined,
            securityMode: this.securityMode,
            maxChunkSize: this._transport.receiveBufferSize || 0,
            maxChunkCount: this._transport.maxChunkCount || 0,
            maxMessageSize: this._transport.maxMessageSize || 0
        });
        if (node_opcua_transport_2.doTraceChunk) {
            console.log(chalk.cyan((0, node_opcua_utils_1.timestamp)()), "   MESSAGE BUILDER LIMITS", "maxMessageSize = ", this.messageBuilder.maxMessageSize, "maxChunkCount = ", this.messageBuilder.maxChunkCount, "maxChunkSize = ", this.messageBuilder.maxChunkSize, "(", this.messageBuilder.maxChunkSize * this.messageBuilder.maxChunkCount, ")");
        }
        this.messageBuilder
            .on("message", (response, msgType, requestId, channelId) => {
            this._on_message_received(response, msgType, requestId);
        })
            .on("startChunk", () => {
            //
            if (utils_1.doPerfMonitoring) {
                this._tick2 = (0, node_opcua_utils_1.get_clock_tick)();
            }
        })
            .on("abandon", (requestId) => {
            const requestData = this._requests[requestId];
            if (doDebug) {
                debugLog("request id = ", requestId, "message was ", requestData);
            }
            const err = new services_1.ServiceFault({
                responseHeader: {
                    requestHandle: requestId,
                    serviceResult: node_opcua_status_code_1.StatusCodes.BadOperationAbandoned
                }
            });
            const callback = requestData.callback;
            delete this._requests[requestId];
            callback && callback(null, err);
        })
            .on("error", (err, statusCode, requestId) => {
            // istanbul ignore next
            if (!requestId) {
                return;
            }
            let requestData = this._requests[requestId];
            if (doDebug) {
                debugLog("request id = ", requestId, err, "message was ", requestData);
            }
            if (!requestData) {
                warningLog("requestData not found for requestId = ", requestId, "try with ", requestId + 1);
                requestId = requestId + 1;
                requestData = this._requests[requestId];
            }
            if (utils_1.doTraceClientRequestContent) {
                errorLog(" message was 2:", requestData ? requestData.request.toString() : "<null>");
            }
            const callback = requestData.callback;
            delete this._requests[requestId];
            callback && callback(err, undefined);
            this._closeWithError(err, statusCode);
            return;
        });
    }
    getPrivateKey() {
        return this.parent ? this.parent.getPrivateKey() : null;
    }
    getCertificateChain() {
        return this.parent ? this.parent.getCertificateChain() : null;
    }
    getCertificate() {
        return this.parent ? this.parent.getCertificate() : null;
    }
    toString() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let str = "";
        str += "\n securityMode ............. : " + node_opcua_service_secure_channel_1.MessageSecurityMode[this.securityMode];
        str += "\n securityPolicy............ : " + this.securityPolicy;
        str += "\n securityToken ............ : " + (this.securityToken ? this.securityToken.toString() : "null");
        str += "\n serverNonce  ............. : " + (this.serverNonce ? this.serverNonce.toString("hex") : "null");
        str += "\n clientNonce  ............. : " + (this.clientNonce ? this.clientNonce.toString("hex") : "null");
        str += "\n timedOutRequestCount.....  : " + this.timedOutRequestCount;
        str += "\n transportTimeout ......... : " + this.transportTimeout;
        str += "\n is transaction in progress : " + this.isTransactionInProgress();
        str += "\n is connecting ............ : " + this.isConnecting;
        str += "\n is disconnecting ......... : " + this._isDisconnecting;
        str += "\n is opened ................ : " + this.isOpened();
        str += "\n is valid ................. : " + this.isValid();
        str += "\n channelId ................ : " + this.channelId;
        str += "\n transportParameters: ..... : ";
        str += "\n   maxMessageSize (to send) : " + (((_b = (_a = this._transport) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.maxMessageSize) || "<not set>");
        str += "\n   maxChunkCount  (to send) : " + (((_d = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.parameters) === null || _d === void 0 ? void 0 : _d.maxChunkCount) || "<not set>");
        str += "\n   receiveBufferSize(server): " + (((_f = (_e = this._transport) === null || _e === void 0 ? void 0 : _e.parameters) === null || _f === void 0 ? void 0 : _f.receiveBufferSize) || "<not set>");
        str += "\n   sendBufferSize (to send) : " + (((_h = (_g = this._transport) === null || _g === void 0 ? void 0 : _g.parameters) === null || _h === void 0 ? void 0 : _h.sendBufferSize) || "<not set>");
        str += "\n";
        return str;
    }
    isTransactionInProgress() {
        return Object.keys(this._requests).length > 0;
    }
    getClientNonce() {
        return this.clientNonce;
    }
    /**
     * establish a secure channel with the provided server end point.
     *
     * @method create
     * @async
     * @param endpointUrl
     * @param callback the async callback function
     *
     *
     * @example
     *
     *    ```javascript
     *
     *    const secureChannel  = new ClientSecureChannelLayer({});
     *
     *    secureChannel.on("end", function(err) {
     *         console.log("secure channel has ended",err);
     *         if(err) {
     *            console.log(" the connection was closed by an external cause such as server shutdown");
     *        }
     *    });
     *    secureChannel.create("opc.tcp://localhost:1234/UA/Sample", (err) => {
     *         if(err) {
     *              console.log(" cannot establish secure channel" , err);
     *         } else {
     *              console.log("secure channel has been established");
     *         }
     *    });
     *
     *    ```
     */
    create(endpointUrl, callback) {
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            // istanbul ignore next
            if (!this.serverCertificate) {
                return callback(new Error("ClientSecureChannelLayer#create : expecting a server certificate when securityMode is not None"));
            }
            // take the opportunity of this async method to perform some async pre-processing
            if (!this.receiverPublicKey) {
                (0, node_opcua_crypto_1.extractPublicKeyFromCertificate)(this.serverCertificate, (err, publicKey) => {
                    /* istanbul ignore next */
                    if (err) {
                        return callback(err);
                    }
                    /* istanbul ignore next */
                    if (!publicKey) {
                        throw new Error("Internal Error");
                    }
                    this.receiverPublicKey = (0, crypto_1.createPublicKey)(publicKey);
                    this.create(endpointUrl, callback);
                });
                return;
            }
        }
        this.endpointUrl = endpointUrl;
        const transport = new node_opcua_transport_1.ClientTCP_transport(this.requestedTransportSettings);
        transport.timeout = this.transportTimeout;
        doDebug &&
            debugLog("ClientSecureChannelLayer#create creating ClientTCP_transport with  transport.timeout = ", transport.timeout);
        (0, node_opcua_assert_1.assert)(!this._pending_transport);
        this._pending_transport = transport;
        this._establish_connection(transport, endpointUrl, (err) => {
            if (err) {
                doDebug && debugLog(chalk.red("cannot connect to server"));
                this._pending_transport = undefined;
                transport.dispose();
                return callback(err);
            }
            this._on_connection(transport, callback);
        });
    }
    _dispose_transports() {
        if (this._transport) {
            this._bytesRead += this._transport.bytesRead || 0;
            this._bytesWritten += this._transport.bytesWritten || 0;
            this._transport.dispose();
            this._transport = undefined;
        }
        if (this._pending_transport) {
            this._bytesRead += this._pending_transport.bytesRead || 0;
            this._bytesWritten += this._pending_transport.bytesWritten || 0;
            this._pending_transport.dispose();
            this._pending_transport = undefined;
        }
    }
    dispose() {
        this._dispose_transports();
        this.abortConnection(() => {
            /* empty */
        });
        this._cancel_security_token_watchdog();
    }
    abortConnection(callback) {
        if (this._isDisconnecting) {
            doDebug && debugLog("abortConnection already aborting!");
            return callback();
        }
        this._isDisconnecting = true;
        doDebug && debugLog("abortConnection ", !!this.__call);
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        async.series([
            (inner_callback) => {
                if (this.__call) {
                    this.__call.once("abort", () => inner_callback());
                    this.__call._cancelBackoff = true;
                    this.__call.abort();
                    this.__call = null;
                }
                else {
                    inner_callback();
                }
            },
            (inner_callback) => {
                if (!this._pending_transport) {
                    return inner_callback();
                }
                this._pending_transport.disconnect(() => {
                    inner_callback();
                });
            },
            (inner_callback) => {
                if (!this._transport) {
                    return inner_callback();
                }
                this._transport.disconnect(() => {
                    inner_callback();
                });
            }
        ], () => {
            callback();
        });
    }
    /**
     * perform a OPC-UA message transaction, asynchronously.
     * During a transaction, the client sends a request to the server. The provided callback will be invoked
     * at a later stage with the reply from the server, or the error.
     *
     * preconditions:
     *   - the channel must be opened
     *
     * @example
     *
     *    ```javascript
     *    let secure_channel ; // get a  ClientSecureChannelLayer somehow
     *
     *    const request = new BrowseRequest({...});
     *    secure_channel.performMessageTransaction(request, (err,response) => {
     *       if (err) {
     *         // an error has occurred
     *       } else {
     *          assert(response instanceof BrowseResponse);
     *         // do something with response.
     *       }
     *    });
     *    ```
     *
     */
    performMessageTransaction(request, callback) {
        this._performMessageTransaction("MSG", request, callback);
    }
    isValid() {
        if (!this._transport) {
            return false;
        }
        return this._transport.isValid();
    }
    isOpened() {
        return this.isValid() && this._isOpened;
    }
    getDisplayName() {
        if (!this.parent) {
            return "";
        }
        return "" + (this.parent.applicationName ? this.parent.applicationName + " " : "") + this.parent.clientName;
    }
    cancelPendingTransactions(callback) {
        (0, node_opcua_assert_1.assert)(typeof callback === "function", "expecting a callback function, but got " + callback);
        // istanbul ignore next
        if (doDebug) {
            debugLog("cancelPendingTransactions ", this.getDisplayName(), " = ", Object.keys(this._requests)
                .map((k) => this._requests[k].request.constructor.name)
                .join(" "));
        }
        for (const key of Object.keys(this._requests)) {
            // kill timer id
            const transaction = this._requests[key];
            if (transaction.callback) {
                transaction.callback(new Error("Transaction has been canceled because client channel  is being closed"));
            }
        }
        setImmediate(callback);
    }
    /**
     * Close a client SecureChannel ,by sending a CloseSecureChannelRequest to the server.
     *
     *
     * After this call, the connection is closed and no further transaction can be made.
     *
     * @method close
     * @async
     * @param callback
     */
    close(callback) {
        (0, node_opcua_assert_1.assert)(typeof callback === "function", "expecting a callback function, but got " + callback);
        // cancel any pending transaction
        this.cancelPendingTransactions(( /* err?: Error */) => {
            // what the specs says:
            // --------------------
            //   The client closes the connection by sending a CloseSecureChannelRequest and closing the
            //   socket gracefully. When the server receives this message it shall release all resources
            //   allocated for the channel. The server does not send a CloseSecureChannel response
            //
            // ( Note : some servers do  send a CloseSecureChannel though !)
            // there is no need for the security token expiration event to trigger anymore
            this._cancel_security_token_watchdog();
            doDebug && debugLog("Sending CloseSecureChannelRequest to server");
            const request = new services_1.CloseSecureChannelRequest({});
            this.__in_normal_close_operation = true;
            if (!this._transport || this._transport.isDisconnecting()) {
                this.dispose();
                return callback(new Error("Transport disconnected"));
            }
            this._performMessageTransaction("CLO", request, () => {
                this.dispose();
                callback();
            });
        });
    }
    _closeWithError(err, statusCode) {
        if (this._transport) {
            this._transport.prematureTerminate(err, statusCode);
        }
        this.dispose();
    }
    on_transaction_completed(transactionStatistics) {
        /* istanbul ignore next */
        if (utils_1.doTraceStatistics) {
            // dump some statistics about transaction ( time and sizes )
            (0, utils_1._dump_client_transaction_statistics)(transactionStatistics);
        }
        this.emit("end_transaction", transactionStatistics);
    }
    _on_message_received(response, msgType, requestId) {
        //      assert(msgType !== "ERR");
        var _a;
        /* istanbul ignore next */
        if (response.responseHeader.requestHandle !== requestId) {
            warningLog(response.toString());
            errorLog(chalk.red.bgWhite.bold("xxxxx  <<<<<< _on_message_received  ERROR"), "requestId=", requestId, (_a = this._requests[requestId]) === null || _a === void 0 ? void 0 : _a.constructor.name, "response.responseHeader.requestHandle=", response.responseHeader.requestHandle, response.schema.name.padStart(30));
        }
        /* istanbul ignore next */
        if (utils_1.doTraceClientMessage) {
            (0, utils_1.traceClientResponseMessage)(response, this.channelId, this._counter);
        }
        const requestData = this._requests[requestId];
        /* istanbul ignore next */
        if (!requestData) {
            errorLog(chalk.cyan.bold("xxxxx  <<<<<< _on_message_received for unknown or timeout request "), requestId, response.schema.name.padStart(30), response.responseHeader.serviceResult.toString(), this.channelId);
            throw new Error(" =>  invalid requestId =" + requestId);
        }
        const request = requestData.request;
        /* istanbul ignore next */
        if (utils_1.doPerfMonitoring) {
            requestData._tick2 = this._tick2;
        }
        delete this._requests[requestId];
        /* istanbul ignore next */
        if (response.responseHeader.requestHandle !== request.requestHeader.requestHandle) {
            const expected = request.requestHeader.requestHandle;
            const actual = response.responseHeader.requestHandle;
            if (actual !== 0x0) {
                // note some old OPCUA Server, like siemens with OPCUA 1.2 may send 0x00 as a
                // requestHandle, this is not harmful. THis happened with OpenSecureChannelRequest
                // so we only display the warning message if we have a real random discrepancy between the two requestHandle.
                const moreInfo = "Request= " + request.schema.name + " Response = " + response.schema.name;
                const message = " WARNING SERVER responseHeader.requestHandle is invalid" +
                    ": expecting 0x" +
                    expected.toString(16) +
                    "(" +
                    expected +
                    ")" +
                    "  but got 0x" +
                    actual.toString(16) +
                    "(" +
                    actual +
                    ")" +
                    " ";
                debugLog(chalk.red.bold(message), chalk.yellow(moreInfo));
                warningLog(chalk.red.bold(message), chalk.yellow(moreInfo));
                warningLog(request.toString());
            }
        }
        requestData.response = response;
        if (utils_1.doPerfMonitoring) {
            // record tick2 : after response message has been received, before message processing
            requestData._tick2 = this.messageBuilder._tick1;
        }
        requestData.bytesRead = this.messageBuilder.totalMessageSize;
        if (utils_1.doPerfMonitoring) {
            // record tick3 : after response message has been received, before message processing
            requestData._tick3 = (0, node_opcua_utils_1.get_clock_tick)();
        }
        process_request_callback(requestData, null, response);
        if (utils_1.doPerfMonitoring) {
            // record tick4 after callback
            requestData._tick4 = (0, node_opcua_utils_1.get_clock_tick)();
        } // store some statistics
        this._record_transaction_statistics(requestData);
        // notify that transaction is completed
        this.on_transaction_completed(this.last_transaction_stats);
    }
    _record_transaction_statistics(requestData) {
        const request = requestData.request;
        const response = requestData.response;
        // ---------------------------------------------------------------------------------------------------------|-
        //      _tick0                _tick1                         _tick2                       _tick3          _tick4
        //          sending request
        //        |---------------------|  waiting response
        //                              |------------------------------|      receiving response
        //                                                             |---------------------------| process.resp
        //                                                                                  |---------------|
        this.last_transaction_stats = {
            bytesRead: requestData.bytesRead,
            bytesWritten: requestData.bytesWritten_after - requestData.bytesWritten_before,
            lap_processing_response: requestData._tick4 - requestData._tick3,
            lap_receiving_response: requestData._tick3 - requestData._tick2,
            lap_sending_request: requestData._tick1 - requestData._tick0,
            lap_transaction: requestData._tick4 - requestData._tick0,
            lap_waiting_response: requestData._tick2 - requestData._tick1,
            request,
            response
        };
        if (utils_1.doTraceStatistics) {
            (0, utils_1._dump_client_transaction_statistics)(this.last_transaction_stats);
        }
    }
    _cancel_pending_transactions(err) {
        if (doDebug && this._requests) {
            debugLog("_cancel_pending_transactions  ", Object.keys(this._requests), this._transport ? this._transport.name : "no transport");
        }
        if (this._requests) {
            for (const requestData of Object.values(this._requests)) {
                if (requestData) {
                    const request = requestData.request;
                    doDebug &&
                        debugLog("Cancelling pending transaction ", requestData.key, requestData.msgType, request === null || request === void 0 ? void 0 : request.schema.name);
                    process_request_callback(requestData, err);
                }
            }
        }
        this._requests = {};
    }
    _on_transport_closed(err) {
        doDebug && debugLog(" =>ClientSecureChannelLayer#_on_transport_closed  err=", err ? err.message : "null");
        if (this.__in_normal_close_operation) {
            err = undefined;
        }
        this.emit("close", err);
        this._dispose_transports();
        this._cancel_pending_transactions(err);
        this._cancel_security_token_watchdog();
        this.dispose();
    }
    _on_security_token_about_to_expire() {
        if (!this.securityToken) {
            return;
        }
        doDebug &&
            debugLog(" client: Security Token ", this.securityToken.tokenId, " is about to expired, let's raise lifetime_75 event ");
        this.emit("lifetime_75", this.securityToken);
        this._renew_security_token();
    }
    _cancel_security_token_watchdog() {
        if (this._securityTokenTimeoutId) {
            clearTimeout(this._securityTokenTimeoutId);
            this._securityTokenTimeoutId = null;
        }
    }
    _install_security_token_watchdog() {
        if (!this.securityToken) {
            errorLog("Failed to install security token watch dog before securityToken is null!");
            return;
        }
        // install timer event to raise a 'lifetime_75' when security token is about to expired
        // so that client can request for a new security token
        // note that, for speedup in test,
        // it is possible to tweak this interval for test by specifying a tokenRenewalInterval value
        //
        const lifeTime = this.securityToken.revisedLifetime;
        (0, node_opcua_assert_1.assert)(lifeTime !== 0 && lifeTime > 20);
        const percent = 75 / 100.0;
        let timeout = this.tokenRenewalInterval || lifeTime * percent;
        timeout = Math.min(timeout, (lifeTime * 75) / 100);
        timeout = Math.max(timeout, 50); // at least one half second !
        if (doDebug) {
            debugLog(chalk.red.bold(" time until next security token renewal = "), timeout, "( lifetime = ", lifeTime + " -  tokenRenewalInterval =" + this.tokenRenewalInterval);
        }
        (0, node_opcua_assert_1.assert)(this._securityTokenTimeoutId === null);
        // security token renewal should happen without overlapping
        this._securityTokenTimeoutId = setTimeout(() => {
            this._securityTokenTimeoutId = null;
            this._on_security_token_about_to_expire();
        }, timeout);
    }
    _build_client_nonce() {
        if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            return null;
        }
        // create a client Nonce if secure mode is requested
        // Release 1.02 page 23 OPC Unified Architecture, Part 4 Table 7 – OpenSecureChannel Service Parameters
        // clientNonce
        // "This parameter shall have a length equal to key size used for the symmetric
        //  encryption algorithm that is identified by the securityPolicyUri"
        const cryptoFactory = (0, security_policy_1.getCryptoFactory)(this.securityPolicy);
        if (!cryptoFactory) {
            // this securityPolicy may not be support yet ... let's return null
            return null;
        }
        (0, node_opcua_assert_1.assert)(cryptoFactory !== null && typeof cryptoFactory === "object");
        return (0, crypto_1.randomBytes)(cryptoFactory.symmetricKeyLength);
    }
    _open_secure_channel_request(isInitial, callback) {
        (0, node_opcua_assert_1.assert)(this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.Invalid, "invalid security mode");
        // from the specs:
        // The OpenSecureChannel Messages are not signed or encrypted if the SecurityMode is None. The
        // nonces  are ignored and should be set to null. The SecureChannelId and the TokenId are still
        // assigned but no security is applied to Messages exchanged via the channel.
        const msgType = "OPN";
        const requestType = isInitial ? services_1.SecurityTokenRequestType.Issue : services_1.SecurityTokenRequestType.Renew;
        this.clientNonce = this._build_client_nonce();
        this._isOpened = !isInitial;
        // OpenSecureChannel
        const msg = new services_1.OpenSecureChannelRequest({
            clientNonce: this.clientNonce,
            clientProtocolVersion: this.protocolVersion,
            requestHeader: {
                auditEntryId: null
            },
            requestType: requestType,
            requestedLifetime: this.defaultSecureTokenLifetime,
            securityMode: this.securityMode
        });
        this._performMessageTransaction(msgType, msg, (err, response) => {
            // istanbul ignore next
            if (response && response.responseHeader && response.responseHeader.serviceResult !== node_opcua_status_code_1.StatusCodes.Good) {
                warningLog("xxxxx => response.responseHeader.serviceResult ", response.constructor.name, response.responseHeader.serviceResult.toString());
                err = new Error(response.responseHeader.serviceResult.toString());
            }
            if (!err && response) {
                const openSecureChannelResponse = response;
                // record channelId for future transactions
                this.channelId = openSecureChannelResponse.securityToken.channelId;
                // todo : verify that server certificate is  valid
                // A self-signed application instance certificate does not need to be verified with a CA.
                // todo : verify that Certificate URI matches the ApplicationURI of the server
                (0, node_opcua_assert_1.assert)(openSecureChannelResponse.securityToken.tokenId > 0 || msgType === "OPN", "_sendSecureOpcUARequest: invalid token Id ");
                (0, node_opcua_assert_1.assert)(Object.prototype.hasOwnProperty.call(openSecureChannelResponse, "serverNonce"));
                this.securityToken = openSecureChannelResponse.securityToken;
                this.serverNonce = openSecureChannelResponse.serverNonce;
                if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
                    // verify that server nonce if provided is at least 32 bytes long
                    /* istanbul ignore next */
                    if (!openSecureChannelResponse.serverNonce) {
                        warningLog(" client : server nonce is missing !");
                        return callback(new Error(" Invalid server nonce"));
                    }
                    // This parameter shall have a length equal to key size used for the symmetric
                    // encryption algorithm that is identified by the securityPolicyUri.
                    if (openSecureChannelResponse.serverNonce.length !== this.clientNonce.length) {
                        warningLog(" client : server nonce is invalid  (invalid length)!");
                        return callback(new Error(" Invalid server nonce length"));
                    }
                }
                const cryptoFactory = this.messageBuilder.cryptoFactory;
                if (cryptoFactory) {
                    (0, node_opcua_assert_1.assert)(this.serverNonce instanceof Buffer);
                    /* istanbul ignore next */
                    if (!this.serverNonce) {
                        throw new Error("internal error");
                    }
                    this.derivedKeys = (0, security_policy_1.computeDerivedKeys)(cryptoFactory, this.serverNonce, this.clientNonce);
                }
                const derivedServerKeys = this.derivedKeys ? this.derivedKeys.derivedServerKeys : null;
                // istanbul ignore next
                if (doDebug) {
                    debugLog("Server has send a new security Token");
                }
                this.messageBuilder.pushNewToken(this.securityToken, derivedServerKeys);
                this._install_security_token_watchdog();
                this._isOpened = true;
            }
            callback(err || undefined);
        });
    }
    _on_connection(transport, callback) {
        var _a, _b;
        (0, node_opcua_assert_1.assert)(this._pending_transport === transport);
        this._pending_transport = undefined;
        this._transport = transport;
        // install message chunker limits:
        this.messageChunker.maxMessageSize = ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.maxMessageSize) || 0;
        this.messageChunker.maxChunkCount = ((_b = this._transport) === null || _b === void 0 ? void 0 : _b.maxChunkCount) || 0;
        this._install_message_builder();
        this._transport.on("chunk", (messageChunk) => {
            this.emit("receive_chunk", messageChunk);
            this._on_receive_message_chunk(messageChunk);
        });
        this._transport.on("close", (err) => this._on_transport_closed(err));
        this._transport.on("connection_break", () => {
            doDebug && debugLog(chalk.red("Client => CONNECTION BREAK  <="));
            this._on_transport_closed(new Error("Connection Break"));
        });
        setImmediate(() => {
            doDebug && debugLog(chalk.red("Client now sending OpenSecureChannel"));
            const isInitial = true;
            this._open_secure_channel_request(isInitial, callback);
        });
    }
    _backoff_completion(err, lastError, transport, callback) {
        if (this.__call) {
            // console log =
            transport.numberOfRetry = transport.numberOfRetry || 0;
            transport.numberOfRetry += this.__call.getNumRetries();
            this.__call.removeAllListeners();
            this.__call = null;
            if (err) {
                callback(lastError || err);
            }
            else {
                callback();
            }
        }
    }
    _connect(transport, endpointUrl, _i_callback) {
        const on_connect = (err) => {
            doDebug && debugLog("Connection => err", err ? err.message : "null");
            // force Backoff to fail if err is not ECONNRESET or ECONNREFUSED
            // this mean that the connection to the server has succeeded but for some reason
            // the server has denied the connection
            // the cause could be:
            //   - invalid protocol version specified by client
            //   - server going to shutdown
            //   - server too busy -
            //   - server shielding itself from a DDOS attack
            if (err) {
                let should_abort = this._isDisconnecting;
                if (err.message.match(/ECONNRESET/)) {
                    should_abort = true;
                }
                if (err.message.match(/BadProtocolVersionUnsupported/)) {
                    should_abort = true;
                }
                if (err.message.match(/BadTcpInternalError/)) {
                    should_abort = true;
                }
                if (err.message.match(/BadTcpMessageTooLarge/)) {
                    should_abort = true;
                }
                if (err.message.match(/BadTcpEndpointUriInvalid/)) {
                    should_abort = true;
                }
                if (err.message.match(/BadTcpMessageTypeInvalid/)) {
                    should_abort = true;
                }
                this.lastError = err;
                if (this.__call) {
                    // connection cannot be establish ? if not, abort the backoff process
                    if (should_abort) {
                        doDebug && debugLog(" Aborting backoff process prematurely - err = ", err.message);
                        this.__call.abort();
                    }
                    else {
                        doDebug && debugLog(" backoff - keep trying - err = ", err.message);
                    }
                }
            }
            _i_callback(err);
        };
        transport.connect(endpointUrl, on_connect);
    }
    _establish_connection(transport, endpointUrl, callback) {
        transport.protocolVersion = this.protocolVersion;
        this.lastError = undefined;
        if (this.connectionStrategy.maxRetry === 0) {
            doDebug && debugLog(chalk.cyan("max Retry === 0 =>  No backoff required -> call the _connect function directly"));
            this.__call = 0;
            return this._connect(transport, endpointUrl, callback);
        }
        const connectFunc = (callback2) => {
            return this._connect(transport, endpointUrl, callback2);
        };
        const completionFunc = (err) => {
            return this._backoff_completion(err, this.lastError, transport, callback);
        };
        this.__call = backoff.call(connectFunc, completionFunc);
        if (this.connectionStrategy.maxRetry >= 0) {
            const maxRetry = Math.max(this.connectionStrategy.maxRetry, 1);
            doDebug && debugLog(chalk.cyan("backoff will failed after "), maxRetry);
            this.__call.failAfter(maxRetry);
        }
        else {
            // retry will be infinite
            doDebug && debugLog(chalk.cyan("backoff => starting a infinite retry"));
        }
        const onBackoffFunc = (retryCount, delay) => {
            doDebug &&
                debugLog(chalk.bgWhite.cyan(" Backoff #"), retryCount, "delay = ", delay, " ms", " maxRetry ", this.connectionStrategy.maxRetry);
            // Do something when backoff starts, e.g. show to the
            // user the delay before next reconnection attempt.
            this.emit("backoff", retryCount, delay);
        };
        this.__call.on("backoff", onBackoffFunc);
        this.__call.on("abort", () => {
            doDebug && debugLog(chalk.bgWhite.cyan(` abort #   after ${this.__call.getNumRetries()} retries.`));
            // Do something when backoff starts, e.g. show to the
            // user the delay before next reconnection attempt.
            this.emit("abort");
            setImmediate(() => {
                this._backoff_completion(undefined, new Error("Connection abandoned"), transport, callback);
            });
        });
        this.__call.setStrategy(new backoff.ExponentialStrategy(this.connectionStrategy));
        this.__call.start();
    }
    _renew_security_token() {
        doDebug && debugLog("ClientSecureChannelLayer#_renew_security_token");
        // istanbul ignore next
        if (!this.isValid()) {
            // this may happen if the communication has been closed by the client or the sever
            warningLog("Invalid socket => Communication has been lost, cannot renew token");
            return;
        }
        const isInitial = false;
        this._open_secure_channel_request(isInitial, (err) => {
            /* istanbul ignore else */
            if (!err) {
                doDebug && debugLog(" token renewed");
                this.emit("security_token_renewed");
            }
            else {
                //if (doDebug) {
                errorLog("ClientSecureChannelLayer: Warning: securityToken hasn't been renewed -> err ", err.message);
                // //}
                // // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX CHECK ME !!!
                // this._closeWithError(
                //     new Error("Restarting because Request has timed out during OpenSecureChannel"),
                //     StatusCodes2.BadRequestTimeout
                // );
            }
        });
    }
    _on_receive_message_chunk(messageChunk) {
        /* istanbul ignore next */
        if (doDebug1) {
            const _stream = new node_opcua_binary_stream_1.BinaryStream(messageChunk);
            const messageHeader = (0, node_opcua_chunkmanager_1.readMessageHeader)(_stream);
            debugLog("CLIENT RECEIVED " + chalk.yellow(JSON.stringify(messageHeader) + ""));
            debugLog("\n" + (0, node_opcua_debug_1.hexDump)(messageChunk));
            debugLog((0, message_header_to_string_1.messageHeaderToString)(messageChunk));
        }
        this.messageBuilder.feed(messageChunk);
    }
    /**
     * @method makeRequestId
     * @return  newly generated request id
     * @private
     */
    makeRequestId() {
        this._lastRequestId += 1;
        return this._lastRequestId;
    }
    /**
     * internal version of _performMessageTransaction.
     *
     * @method _performMessageTransaction
     * @private
     *
     * - this method takes a extra parameter : msgType
     * TODO:
     * - this method can be re-entrant, meaning that a new transaction can be started before any pending transaction
     *   is fully completed.
     * - Any error on transport will cause all pending transactions to be cancelled
     *
     * - the method returns a timeout Error if the server fails to return a response within the timeoutHint interval.
     *
     *
     */
    _performMessageTransaction(msgType, request, callback) {
        if (!this.isValid()) {
            return callback(new Error("ClientSecureChannelLayer => Socket is closed ! while processing " + request.constructor.name));
        }
        let localCallback = callback;
        let timeout = request.requestHeader.timeoutHint || ClientSecureChannelLayer.defaultTransactionTimeout;
        timeout = Math.max(ClientSecureChannelLayer.minTransactionTimeout, timeout);
        // adjust request timeout
        request.requestHeader.timeoutHint = timeout;
        /* istanbul ignore next */
        if (doDebug) {
            debugLog("Adjusted timeout = ", request.requestHeader.timeoutHint);
        }
        let timerId = null;
        let hasTimedOut = false;
        const modified_callback = (err, response) => {
            /* istanbul ignore next */
            if (doDebug) {
                debugLog(chalk.cyan("------------------------------------- Client receiving response "), request.constructor.name, request.requestHeader.requestHandle, response ? response.constructor.name : "null", "err=", err ? err.message : "null", "securityTokenId=", this.securityToken ? this.securityToken.tokenId : "x");
            }
            if (response && utils_1.doTraceClientRequestContent) {
                warningLog(response.toString());
            }
            if (!localCallback) {
                return; // already processed by time  out
            }
            // when response === null we are processing the timeout , therefore there is no need to clearTimeout
            if (!hasTimedOut && timerId) {
                clearTimeout(timerId);
            }
            timerId = null;
            if (!err && response) {
                this.emit("receive_response", response);
            }
            (0, node_opcua_assert_1.assert)(!err || util_1.types.isNativeError(err));
            delete this._requests[request.requestHeader.requestHandle];
            // invoke user callback if it has not been intercepted first ( by a abrupt disconnection for instance )
            try {
                localCallback.call(this, err || null, response);
            }
            catch (err1) {
                errorLog("ERROR !!! callback has thrown en error ", err1);
                callback(err || null);
            }
            finally {
                localCallback = null;
            }
        };
        const optionalTrace = !checkTimeout || new Error().stack;
        timerId = setTimeout(() => {
            timerId = null;
            hasTimedOut = true;
            if (checkTimeout) {
                warningLog(" Timeout .... waiting for response for ", request.constructor.name, request.requestHeader.toString());
                warningLog(" Timeout was ", timeout, "ms");
                warningLog(request.toString());
                warningLog(optionalTrace);
            }
            modified_callback(new Error("Transaction has timed out ( timeout = " + timeout + " ms , request = " + request.constructor.name + ")"));
            this._timeout_request_count += 1;
            this.emit("timed_out_request", request);
            // xx // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX CHECK ME !!!
            // xx this.closeWithError(new Error("Restarting because Request has timed out (1)"), () => { });
        }, timeout);
        const transaction_data = {
            callback: modified_callback,
            msgType: msgType,
            request: request,
            timerId: timerId
        };
        this._internal_perform_transaction(transaction_data);
    }
    /**
     *
     * @param transactionData
     * @param transactionData.msgType
     * @param transactionData.request
     * @param transactionData.callback
     * @private
     */
    _internal_perform_transaction(transactionData) {
        (0, node_opcua_assert_1.assert)(typeof transactionData.callback === "function");
        if (!this._transport) {
            setTimeout(() => {
                transactionData.callback(new Error("Client not connected"));
            }, 100);
            return;
        }
        (0, node_opcua_assert_1.assert)(this._transport, " must have a valid transport");
        const msgType = transactionData.msgType;
        const request = transactionData.request;
        (0, node_opcua_assert_1.assert)(msgType.length === 3);
        // get a new requestId
        const requestHandle = this.makeRequestId();
        /* istanbul ignore next */
        if (request.requestHeader.requestHandle !== exports.requestHandleNotSetValue) {
            errorLog(chalk.bgRed.white("xxxxx   >>>>>> request has already been set with a requestHandle"), requestHandle, request.requestHeader.requestHandle, request.constructor.name);
            errorLog(Object.keys(this._requests).join(" "));
            errorLog(new Error("Investigate me"));
        }
        request.requestHeader.requestHandle = requestHandle;
        /* istanbul ignore next */
        if (utils_1.doTraceClientMessage) {
            (0, utils_1.traceClientRequestMessage)(request, this.channelId, this._counter);
        }
        const requestData = {
            callback: transactionData.callback,
            msgType: msgType,
            request: request,
            bytesRead: 0,
            bytesWritten_after: 0,
            bytesWritten_before: this.bytesWritten,
            _tick0: 0,
            _tick1: 0,
            _tick2: 0,
            _tick3: 0,
            _tick4: 0,
            key: "",
            chunk_count: 0
        };
        this._requests[requestHandle] = requestData;
        /* istanbul ignore next */
        if (utils_1.doPerfMonitoring) {
            const stats = requestData;
            // record tick0 : before request is being sent to server
            stats._tick0 = (0, node_opcua_utils_1.get_clock_tick)();
        }
        // check that limits are OK
        this._sendSecureOpcUARequest(msgType, request, requestHandle);
    }
    _send_chunk(requestId, chunk) {
        var _a;
        const requestData = this._requests[requestId];
        if (chunk) {
            this.emit("send_chunk", chunk);
            /* istanbul ignore next */
            if (checkChunks) {
                (0, node_opcua_chunkmanager_1.verify_message_chunk)(chunk);
                debugLog(chalk.yellow("CLIENT SEND chunk "));
                debugLog(chalk.yellow((0, message_header_to_string_1.messageHeaderToString)(chunk)));
                debugLog(chalk.red((0, node_opcua_debug_1.hexDump)(chunk)));
            }
            (0, node_opcua_assert_1.assert)(this._transport);
            (_a = this._transport) === null || _a === void 0 ? void 0 : _a.write(chunk);
            requestData.chunk_count += 1;
        }
        else {
            // last chunk ....
            /* istanbul ignore next */
            if (checkChunks) {
                debugLog(chalk.yellow("CLIENT SEND done."));
            }
            if (requestData) {
                if (utils_1.doPerfMonitoring) {
                    requestData._tick1 = (0, node_opcua_utils_1.get_clock_tick)();
                }
                requestData.bytesWritten_after = this.bytesWritten;
            }
        }
    }
    _construct_security_header() {
        this.receiverCertificate = this.serverCertificate ? Buffer.from(this.serverCertificate) : null;
        let securityHeader = null;
        switch (this.securityMode) {
            case node_opcua_service_secure_channel_1.MessageSecurityMode.Sign:
            case node_opcua_service_secure_channel_1.MessageSecurityMode.SignAndEncrypt: {
                (0, node_opcua_assert_1.assert)(this.securityPolicy !== security_policy_1.SecurityPolicy.None);
                // get the thumbprint of the client certificate
                const receiverCertificateThumbprint = (0, common_1.getThumbprint)(this.receiverCertificate);
                securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
                    receiverCertificateThumbprint,
                    securityPolicyUri: (0, security_policy_1.toURI)(this.securityPolicy),
                    /**
                     * The X.509 v3 Certificate assigned to the sending application Instance.
                     *  This is a DER encoded blob.
                     * The structure of an X.509 v3 Certificate is defined in X.509 v3.
                     * The DER format for a Certificate is defined in X690
                     * This indicates what Private Key was used to sign the MessageChunk.
                     * The Stack shall close the channel and report an error to the application if the SenderCertificate is too large for the buffer size supported by the transport layer.
                     * This field shall be null if the Message is not signed.
                     * If the Certificate is signed by a CA, the DER encoded CA Certificate may be
                     * appended after the Certificate in the byte array. If the CA Certificate is also
                     * signed by another CA this process is repeated until the entire Certificate chain
                     *  is in the buffer or if MaxSenderCertificateSize limit is reached (the process
                     * stops after the last whole Certificate that can be added without exceeding
                     * the MaxSenderCertificateSize limit).
                     * Receivers can extract the Certificates from the byte array by using the Certificate
                     *  size contained in DER header (see X.509 v3).
                     */
                    senderCertificate: this.getCertificateChain() // certificate of the private key used to sign the message
                });
                if (utils_1.dumpSecurityHeader) {
                    warningLog("HEADER !!!! ", securityHeader.toString());
                }
                break;
            }
            default:
                /* istanbul ignore next */
                (0, node_opcua_assert_1.assert)(false, "invalid security mode");
        }
        this.securityHeader = securityHeader;
    }
    _get_security_options_for_OPN() {
        if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            return null;
        }
        this._construct_security_header();
        this.messageChunker.securityHeader = this.securityHeader;
        const senderPrivateKey = this.getPrivateKey();
        if (!senderPrivateKey) {
            throw new Error("invalid senderPrivateKey");
        }
        const cryptoFactory = (0, security_policy_1.getCryptoFactory)(this.securityPolicy);
        if (!cryptoFactory) {
            return null; // may be a not yet supported security Policy
        }
        (0, node_opcua_assert_1.assert)(cryptoFactory, "expecting a cryptoFactory");
        (0, node_opcua_assert_1.assert)(typeof cryptoFactory.asymmetricSign === "function");
        const options = {};
        options.signatureLength = (0, node_opcua_crypto_1.rsaLengthPrivateKey)(senderPrivateKey);
        options.signBufferFunc = (chunk) => {
            const s = cryptoFactory.asymmetricSign(chunk, senderPrivateKey);
            (0, node_opcua_assert_1.assert)(s.length === options.signatureLength);
            return s;
        };
        // istanbul ignore next
        if (!this.receiverPublicKey) {
            throw new Error(" invalid receiverPublicKey");
        }
        const keyLength = (0, node_opcua_crypto_1.rsaLengthPublicKey)(this.receiverPublicKey);
        options.plainBlockSize = keyLength - cryptoFactory.blockPaddingSize;
        options.cipherBlockSize = keyLength;
        const receiverPublicKey = this.receiverPublicKey;
        options.encryptBufferFunc = (chunk) => {
            return cryptoFactory.asymmetricEncrypt(chunk, receiverPublicKey);
        };
        return options;
    }
    _get_security_options_for_MSG() {
        if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            return null;
        }
        // istanbul ignore next
        if (!this.derivedKeys || !this.derivedKeys.derivedClientKeys) {
            errorLog("derivedKeys not set but security mode = ", node_opcua_service_secure_channel_1.MessageSecurityMode[this.securityMode]);
            return null; //
            // throw new Error("internal error expecting valid derivedKeys while security mode is " + MessageSecurityMode[this.securityMode]);
        }
        const derivedClientKeys = this.derivedKeys.derivedClientKeys;
        (0, node_opcua_assert_1.assert)(derivedClientKeys, "expecting valid derivedClientKeys");
        return (0, security_policy_1.getOptionsForSymmetricSignAndEncrypt)(this.securityMode, derivedClientKeys);
    }
    _sendSecureOpcUARequest(msgType, request, requestId) {
        var _a, _b;
        const tokenId = this.securityToken ? this.securityToken.tokenId : 0;
        // assert(this.channelId !== 0 , "channel Id cannot be null");
        let options = {
            channelId: this.channelId,
            chunkSize: 0,
            requestId,
            tokenId,
            cipherBlockSize: 0,
            plainBlockSize: 0,
            sequenceHeaderSize: 0,
            signatureLength: 0
        };
        // use chunk size that has been negotiated by the transport layer
        if (((_a = this._transport) === null || _a === void 0 ? void 0 : _a.parameters) && ((_b = this._transport) === null || _b === void 0 ? void 0 : _b.parameters.sendBufferSize)) {
            options.chunkSize = this._transport.parameters.sendBufferSize;
        }
        /* istanbul ignore next */
        if (request.requestHeader.requestHandle !== options.requestId) {
            doDebug &&
                debugLog(chalk.red.bold("------------------------------------- Invalid request id"), request.requestHeader.requestHandle, options.requestId);
        }
        request.requestHeader.returnDiagnostics = 0x0;
        /* istanbul ignore next */
        if (utils_1.doTraceClientRequestContent) {
            warningLog(chalk.yellow.bold("------------------------------------- Client Sending a request  "), request.constructor.name, "h=", request.requestHeader.requestHandle, " channel id ", this.channelId, " securityToken=", this.securityToken ? this.securityToken.tokenId : "x");
        }
        if (utils_1.doTraceClientRequestContent) {
            warningLog(request.toString());
        }
        const security_options = msgType === "OPN" ? this._get_security_options_for_OPN() : this._get_security_options_for_MSG();
        if (security_options) {
            options = Object.assign(Object.assign({}, options), security_options);
        }
        this.emit("send_request", request);
        this.messageChunker.chunkSecureMessage(msgType, options, request, (err, chunk) => {
            if (err) {
                // the messageChunk has not send anything due to an error detected in the chunker
                const response = new services_1.ServiceFault({
                    responseHeader: {
                        serviceResult: node_opcua_status_code_1.StatusCodes.BadInternalError,
                        stringTable: [err.message]
                    }
                });
                this._send_chunk(requestId, null);
                this._on_message_received(response, "ERR", request.requestHeader.requestHandle);
            }
            else {
                this._send_chunk(requestId, chunk);
            }
        });
    }
}
ClientSecureChannelLayer.g_counter = 0;
ClientSecureChannelLayer.minTransactionTimeout = 5 * 1000; // 10 sec
ClientSecureChannelLayer.defaultTransactionTimeout = 15 * 1000; // 15 minute
ClientSecureChannelLayer.defaultTransportTimeout = 60 * 1000; // 60 seconds
exports.ClientSecureChannelLayer = ClientSecureChannelLayer;
//# sourceMappingURL=client_secure_channel_layer.js.map