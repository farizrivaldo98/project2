/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from "events";
import { Certificate, PublicKeyLength, PrivateKey } from "node-opcua-crypto";
import { MessageSecurityMode } from "node-opcua-service-secure-channel";
import { StatusCode } from "node-opcua-status-code";
import { ISocketLike } from "node-opcua-transport";
import { ErrorCallback } from "node-opcua-status-code";
import { EndpointDescription } from "node-opcua-service-endpoints";
import { ICertificateManager } from "node-opcua-certificate-manager";
import { ObjectRegistry } from "node-opcua-object-registry";
import { SecurityHeader } from "../secure_message_chunk_manager";
import { ICertificateKeyPairProvider, Request, Response } from "../common";
import { MessageBuilder, ObjectFactory } from "../message_builder";
import { SecurityPolicy } from "../security_policy";
import { AsymmetricAlgorithmSecurityHeader } from "../services";
export interface ServerSecureChannelParent extends ICertificateKeyPairProvider {
    certificateManager: ICertificateManager;
    getCertificate(): Certificate;
    getCertificateChain(): Certificate;
    getPrivateKey(): PrivateKey;
    getEndpointDescription(securityMode: MessageSecurityMode, securityPolicy: SecurityPolicy, endpointUri: string | null): EndpointDescription | null;
}
export interface ServerSecureChannelLayerOptions {
    parent: ServerSecureChannelParent;
    /**
     * timeout in milliseconds [default = 30000]
     */
    timeout?: number;
    /**
     * default secure token life time in milliseconds [default = 300000]
     */
    defaultSecureTokenLifetime?: number;
    objectFactory?: ObjectFactory;
}
export interface IServerSession {
    keepAlive?: () => void;
    status: string;
    incrementTotalRequestCount(): void;
    incrementRequestErrorCounter(counterName: string): void;
    incrementRequestTotalCounter(counterName: string): void;
}
export interface Message {
    request: Request;
    requestId: number;
    securityHeader?: SecurityHeader;
    channel?: ServerSecureChannelLayer;
    session?: IServerSession;
    session_statusCode?: StatusCode;
}
/**
 * returns true if the nonce is null or zero (all bytes set to 0)
 */
export declare function isEmptyNonce(nonce: Buffer): boolean;
export declare function nonceAlreadyBeenUsed(nonce?: Buffer): boolean;
export interface IServerSessionBase {
    sessionTimeout: number;
    sessionName: string;
    clientLastContactTime: number;
    status: string;
}
/**
 * @class ServerSecureChannelLayer
 * @extends EventEmitter
 * @uses MessageBuilder
 * @uses MessageChunker
 */
export declare class ServerSecureChannelLayer extends EventEmitter {
    static throttleTime: number;
    private static g_MinimumSecureTokenLifetime;
    private static g_counter;
    private _counter;
    get securityTokenCount(): number;
    get remoteAddress(): string;
    get remotePort(): number;
    /**
     *
     */
    get aborted(): boolean;
    /**
     * the number of bytes read so far by this channel
     */
    get bytesRead(): number;
    /**
     * the number of bytes written so far by this channel
     */
    get bytesWritten(): number;
    get transactionsCount(): number;
    /**
     * true when the secure channel has been opened successfully
     *
     */
    get isOpened(): boolean;
    /**
     * true when the secure channel is assigned to a active session
     */
    get hasSession(): boolean;
    get certificateManager(): ICertificateManager;
    /**
     * The unique hash key to identify this secure channel
     * @property hashKey
     */
    get hashKey(): number;
    static registry: ObjectRegistry;
    _on_response: ((msgType: string, response: Response, message: Message) => void) | null;
    sessionTokens: {
        [key: string]: IServerSessionBase;
    };
    channelId: number | null;
    timeout: number;
    messageBuilder?: MessageBuilder;
    receiverCertificate: Buffer | null;
    clientCertificate: Buffer | null;
    clientNonce: Buffer | null;
    /**
     * the channel message security mode
     */
    securityMode: MessageSecurityMode;
    /**
     * the channel message security policy
     */
    securityPolicy: SecurityPolicy;
    securityHeader: AsymmetricAlgorithmSecurityHeader | null;
    clientSecurityHeader?: SecurityHeader;
    private readonly __hash;
    private parent;
    private readonly protocolVersion;
    private lastTokenId;
    private readonly defaultSecureTokenLifetime;
    private securityToken;
    private serverNonce;
    private receiverPublicKey;
    private receiverPublicKeyLength;
    private readonly messageChunker;
    private timeoutId;
    private _open_secure_channel_onceClose;
    private _securityTokenTimeout;
    private _transactionsCount;
    private revisedLifetime;
    private readonly transport;
    private derivedKeys?;
    private objectFactory?;
    private last_transaction_stats?;
    private _tick0;
    private _tick1;
    private _tick2;
    private _tick3;
    private _bytesRead_before;
    private _bytesWritten_before;
    private _remoteAddress;
    private _remotePort;
    private _abort_has_been_called;
    private __verifId;
    private _transport_socket_close_listener?;
    constructor(options: ServerSecureChannelLayerOptions);
    getTransportSettings(): {
        maxMessageSize: number;
    };
    private _build_message_builder;
    dispose(): void;
    abruptlyInterrupt(): void;
    /**
     * the endpoint associated with this secure channel
     *
     */
    getEndpointDescription(securityMode: MessageSecurityMode, securityPolicy: SecurityPolicy, endpointUri: string | null): EndpointDescription | null;
    setSecurity(securityMode: MessageSecurityMode, securityPolicy: SecurityPolicy): void;
    /**
     * @method getCertificateChain
     * @return the X509 DER form certificate
     */
    getCertificateChain(): Certificate;
    /**
     * @method getCertificate
     * @return  the X509 DER form certificate
     */
    getCertificate(): Certificate;
    getSignatureLength(): PublicKeyLength;
    /**
     * @method getPrivateKey
     * @return the privateKey
     */
    getPrivateKey(): PrivateKey;
    /**
     * @method init
     * @async
     * @param socket
     * @param callback
     */
    init(socket: ISocketLike, callback: ErrorCallback): void;
    /**
     * @method send_response
     * @async
     * @param msgType
     * @param response
     * @param message
     * @param callback
     */
    send_response(msgType: string, response: Response, message: Message, callback?: ErrorCallback): void;
    private _sendFatalErrorAndAbort;
    getRemoteIPAddress(): string;
    getRemotePort(): number;
    getRemoteFamily(): string;
    /**
     * Abruptly close a Server SecureChannel ,by terminating the underlying transport.
     *
     *
     * @method close
     * @async
     * @param callback
     */
    close(callback?: ErrorCallback): void;
    has_endpoint_for_security_mode_and_policy(securityMode: MessageSecurityMode, securityPolicy: SecurityPolicy): boolean;
    _rememberClientAddressAndPort(): void;
    private _stop_security_token_watch_dog;
    private _start_security_token_watch_dog;
    private _add_new_security_token;
    private _prepare_security_token;
    private _set_lifetime;
    private _stop_open_channel_watch_dog;
    private _cleanup_pending_timers;
    private _cancel_wait_for_open_secure_channel_request_timeout;
    private _install_wait_for_open_secure_channel_request_timeout;
    private _on_initial_open_secure_channel_request;
    private _wait_for_open_secure_channel_request;
    private _send_chunk;
    private _get_security_options_for_OPN;
    private _get_security_options_for_MSG;
    /**
     * _process_certificates extracts client public keys from client certificate
     *  and store them in self.receiverPublicKey and self.receiverCertificate
     *  it also caches self.receiverPublicKeyLength.
     *
     *  so they can be used by security channel.
     *
     * @method _process_certificates
     * @param message the message coming from the client
     * @param callback
     * @private
     * @async
     */
    private _process_certificates;
    private _prepare_security_header;
    protected checkCertificateCallback(certificate: Certificate | null, callback: (err: Error | null, statusCode?: StatusCode) => void): void;
    protected checkCertificate(certificate: Certificate | null): Promise<StatusCode>;
    private _handle_OpenSecureChannelRequest;
    private _abort;
    private _record_transaction_statistics;
    private _on_common_message;
    /**
     * @method _check_receiverCertificateThumbprint
     * verify that the receiverCertificateThumbprint send by the client
     * matching the CertificateThumbPrint of the server
     * @param clientSecurityHeader
     * @return true if the receiver certificate thumbprint matches the server certificate
     * @private
     */
    private _check_receiverCertificateThumbprint;
    private _on_OpenSecureChannelRequestError;
}
