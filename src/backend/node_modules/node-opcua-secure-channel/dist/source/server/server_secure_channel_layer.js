"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerSecureChannelLayer = exports.nonceAlreadyBeenUsed = exports.isEmptyNonce = void 0;
/* eslint-disable max-statements */
/**
 * @module node-opcua-secure-channel
 */
const crypto = require("crypto");
const events_1 = require("events");
const util_1 = require("util");
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_packet_analyzer_1 = require("node-opcua-packet-analyzer");
const node_opcua_service_secure_channel_1 = require("node-opcua-service-secure-channel");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_transport_1 = require("node-opcua-transport");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_opcua_object_registry_1 = require("node-opcua-object-registry");
const node_opcua_transport_2 = require("node-opcua-transport");
const common_1 = require("../common");
const message_builder_1 = require("../message_builder");
const message_chunker_1 = require("../message_chunker");
const security_policy_1 = require("../security_policy");
const services_1 = require("../services");
const utils_1 = require("../utils");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
const allowNullRequestId = true;
let gLastChannelId = 0;
function getNextChannelId() {
    gLastChannelId += 1;
    return gLastChannelId;
}
function isValidSecurityPolicy(securityPolicy) {
    switch (securityPolicy) {
        case security_policy_1.SecurityPolicy.None:
        case security_policy_1.SecurityPolicy.Basic128Rsa15:
        case security_policy_1.SecurityPolicy.Basic256:
        case security_policy_1.SecurityPolicy.Basic256Sha256:
        case security_policy_1.SecurityPolicy.Aes128_Sha256_RsaOaep:
        case security_policy_1.SecurityPolicy.Aes256_Sha256_RsaPss:
            return node_opcua_status_code_1.StatusCodes.Good;
        default:
            return node_opcua_status_code_1.StatusCodes.BadSecurityPolicyRejected;
    }
}
/**
 * returns true if the nonce is null or zero (all bytes set to 0)
 */
function isEmptyNonce(nonce) {
    const countZero = nonce.reduce((accumulator, currentValue) => accumulator + (currentValue === 0 ? 1 : 0), 0);
    return countZero === nonce.length;
}
exports.isEmptyNonce = isEmptyNonce;
const g_alreadyUsedNonce = {};
function nonceAlreadyBeenUsed(nonce) {
    if (!nonce || isEmptyNonce(nonce)) {
        return false;
    }
    const hash = nonce.toString("base64");
    if (Object.prototype.hasOwnProperty.call(g_alreadyUsedNonce, hash)) {
        return true;
    }
    g_alreadyUsedNonce[hash] = {
        time: new Date()
    };
    return false;
}
exports.nonceAlreadyBeenUsed = nonceAlreadyBeenUsed;
/**
 * @class ServerSecureChannelLayer
 * @extends EventEmitter
 * @uses MessageBuilder
 * @uses MessageChunker
 */
class ServerSecureChannelLayer extends events_1.EventEmitter {
    get securityTokenCount() {
        (0, node_opcua_assert_1.assert)(typeof this.lastTokenId === "number");
        return this.lastTokenId;
    }
    get remoteAddress() {
        return this._remoteAddress;
    }
    get remotePort() {
        return this._remotePort;
    }
    /**
     *
     */
    get aborted() {
        return this._abort_has_been_called;
    }
    /**
     * the number of bytes read so far by this channel
     */
    get bytesRead() {
        return this.transport ? this.transport.bytesRead : 0;
    }
    /**
     * the number of bytes written so far by this channel
     */
    get bytesWritten() {
        return this.transport ? this.transport.bytesWritten : 0;
    }
    get transactionsCount() {
        return this._transactionsCount;
    }
    /**
     * true when the secure channel has been opened successfully
     *
     */
    get isOpened() {
        return !!this.clientCertificate;
    }
    /**
     * true when the secure channel is assigned to a active session
     */
    get hasSession() {
        return Object.keys(this.sessionTokens).length > 0;
    }
    get certificateManager() {
        return this.parent.certificateManager;
    }
    /**
     * The unique hash key to identify this secure channel
     * @property hashKey
     */
    get hashKey() {
        return this.__hash;
    }
    constructor(options) {
        super();
        this._counter = ServerSecureChannelLayer.g_counter++;
        /**
         * the channel message security policy
         */
        this.securityPolicy = security_policy_1.SecurityPolicy.Invalid;
        this._open_secure_channel_onceClose = null;
        this._on_response = null;
        this.__verifId = {};
        this._abort_has_been_called = false;
        this._remoteAddress = "";
        this._remotePort = 0;
        this.receiverCertificate = null;
        this.receiverPublicKey = null;
        this.receiverPublicKeyLength = 0;
        this.clientCertificate = null;
        this.clientNonce = null;
        this.transport = new node_opcua_transport_1.ServerTCP_transport();
        this.__hash = getNextChannelId();
        (0, node_opcua_assert_1.assert)(this.__hash > 0);
        this.channelId = null;
        this.revisedLifetime = 0;
        this.parent = options.parent;
        this.protocolVersion = 0;
        this.lastTokenId = 0;
        this.timeout = options.timeout || 30000; // connection timeout
        this.defaultSecureTokenLifetime = options.defaultSecureTokenLifetime || 600000;
        debugLog("server secure channel layer timeout = ", this.timeout, "defaultSecureTokenLifetime = ", this.defaultSecureTokenLifetime);
        // uninitialized securityToken
        this.securityToken = new node_opcua_service_secure_channel_1.ChannelSecurityToken({
            channelId: this.__hash,
            revisedLifetime: 0,
            tokenId: 0
        });
        (0, node_opcua_assert_1.assert)(this.securityToken.channelId > 0);
        this.serverNonce = null; // will be created when needed
        // at first use a anonymous connection
        this.securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
            receiverCertificateThumbprint: null,
            securityPolicyUri: "http://opcfoundation.org/UA/SecurityPolicy#None",
            senderCertificate: null
        });
        this.messageChunker = new message_chunker_1.MessageChunker({
            securityHeader: this.securityHeader,
            maxMessageSize: this.transport.maxMessageSize,
            maxChunkCount: this.transport.maxChunkCount
        });
        this._tick0 = 0;
        this._tick1 = 0;
        this._tick2 = 0;
        this._tick3 = 0;
        this._bytesRead_before = 0;
        this._bytesWritten_before = 0;
        this.securityMode = node_opcua_service_secure_channel_1.MessageSecurityMode.Invalid;
        this.timeoutId = null;
        this._securityTokenTimeout = null;
        this._transactionsCount = 0;
        this.sessionTokens = {};
        this.objectFactory = options.objectFactory;
        // xx #422 self.setMaxListeners(200); // increase the number of max listener
    }
    getTransportSettings() {
        return { maxMessageSize: this.transport.maxMessageSize };
    }
    _build_message_builder() {
        this.messageBuilder = new message_builder_1.MessageBuilder({
            name: "server",
            objectFactory: this.objectFactory,
            privateKey: this.getPrivateKey(),
            maxChunkSize: this.transport.receiveBufferSize,
            maxChunkCount: this.transport.maxChunkCount,
            maxMessageSize: this.transport.maxMessageSize
        });
        debugLog(" this.transport.maxChunkCount", this.transport.maxChunkCount);
        debugLog(" this.transport.maxMessageSize", this.transport.maxMessageSize);
        this.messageBuilder.on("error", (err, statusCode) => {
            warningLog("ServerSecureChannel:MessageBuilder: ", err.message, statusCode.toString());
            // istanbul ignore next
            if (doDebug) {
                debugLog(chalk.red("Error "), err.message, err.stack);
                debugLog(chalk.red("Server is now closing socket, without further notice"));
            }
            this.transport.sendErrorMessage(statusCode, err.message);
            // close socket immediately
            this.close(undefined);
        });
    }
    dispose() {
        debugLog("ServerSecureChannelLayer#dispose");
        this._stop_open_channel_watch_dog();
        (0, node_opcua_assert_1.assert)(!this.timeoutId, "timeout must have been cleared");
        (0, node_opcua_assert_1.assert)(!this._securityTokenTimeout, "_securityTokenTimeout must have been cleared");
        this.parent = null;
        this.serverNonce = null;
        this.objectFactory = undefined;
        if (this.messageBuilder) {
            this.messageBuilder.dispose();
            this.messageBuilder = undefined;
        }
        this.securityHeader = null;
        if (this.messageChunker) {
            this.messageChunker.dispose();
            // xx this.messageChunker = null;
        }
        if (this.transport) {
            this.transport.dispose();
            this.transport = undefined;
        }
        this.channelId = 0xdeadbeef;
        this.timeoutId = null;
        this.sessionTokens = {};
        this.removeAllListeners();
    }
    abruptlyInterrupt() {
        const clientSocket = this.transport._socket;
        if (clientSocket) {
            clientSocket.end();
            clientSocket.destroy();
        }
    }
    /**
     * the endpoint associated with this secure channel
     *
     */
    getEndpointDescription(securityMode, securityPolicy, endpointUri) {
        if (!this.parent) {
            return null; // throw new Error("getEndpointDescription - no parent");
        }
        return this.parent.getEndpointDescription(this.securityMode, securityPolicy, endpointUri);
    }
    setSecurity(securityMode, securityPolicy) {
        if (!this.messageBuilder) {
            this._build_message_builder();
        }
        (0, node_opcua_assert_1.assert)(this.messageBuilder);
        // TODO verify that the endpoint really supports this mode
        this.messageBuilder.setSecurity(securityMode, securityPolicy);
    }
    /**
     * @method getCertificateChain
     * @return the X509 DER form certificate
     */
    getCertificateChain() {
        if (!this.parent) {
            throw new Error("expecting a valid parent");
        }
        return this.parent.getCertificateChain();
    }
    /**
     * @method getCertificate
     * @return  the X509 DER form certificate
     */
    getCertificate() {
        if (!this.parent) {
            throw new Error("expecting a valid parent");
        }
        return this.parent.getCertificate();
    }
    getSignatureLength() {
        const firstCertificateInChain = this.getCertificate();
        const cert = (0, node_opcua_crypto_1.exploreCertificateInfo)(firstCertificateInChain);
        return cert.publicKeyLength; // 1024 bits = 128Bytes or 2048=256Bytes
    }
    /**
     * @method getPrivateKey
     * @return the privateKey
     */
    getPrivateKey() {
        if (!this.parent) {
            return message_builder_1.invalidPrivateKey;
            // throw new Error("getPrivateKey : cannot get PrivateKey");
        }
        return this.parent.getPrivateKey();
    }
    /**
     * @method init
     * @async
     * @param socket
     * @param callback
     */
    init(socket, callback) {
        this.transport.timeout = this.timeout;
        debugLog("Setting socket timeout to ", this.transport.timeout);
        this.transport.init(socket, (err) => {
            if (err) {
                callback(err);
            }
            else {
                this._build_message_builder();
                this._rememberClientAddressAndPort();
                // adjust sizes;
                this.messageChunker.maxMessageSize = this.transport.maxMessageSize;
                this.messageChunker.maxChunkCount = this.transport.maxChunkCount;
                // bind low level TCP transport to messageBuilder
                this.transport.on("chunk", (messageChunk) => {
                    // istanbul ignore next
                    if (node_opcua_transport_2.doTraceIncomingChunk) {
                        console.log((0, node_opcua_crypto_1.hexDump)(messageChunk));
                    }
                    this.messageBuilder.feed(messageChunk);
                });
                debugLog("ServerSecureChannelLayer : Transport layer has been initialized");
                debugLog("... now waiting for OpenSecureChannelRequest...");
                ServerSecureChannelLayer.registry.register(this);
                this._wait_for_open_secure_channel_request(callback, this.timeout);
            }
        });
        // detect transport closure
        this._transport_socket_close_listener = (err) => {
            debugLog("transport has send 'close' event " + (err ? err.message : "null"));
            this._abort();
        };
        this.transport.on("close", this._transport_socket_close_listener);
    }
    /**
     * @method send_response
     * @async
     * @param msgType
     * @param response
     * @param message
     * @param callback
     */
    send_response(msgType, response, message, callback) {
        const request = message.request;
        const requestId = message.requestId;
        (0, node_opcua_assert_1.assert)(allowNullRequestId || requestId !== 0);
        if (this.aborted) {
            debugLog("channel has been terminated , cannot send responses");
            return callback && callback(new Error("Aborted"));
        }
        // istanbul ignore next
        if (doDebug) {
            (0, node_opcua_assert_1.assert)(request.schema);
            (0, node_opcua_assert_1.assert)(allowNullRequestId || requestId > 0);
            // verify that response for a given requestId is only sent once.
            if (!this.__verifId) {
                this.__verifId = {};
            }
            (0, node_opcua_assert_1.assert)(!this.__verifId[requestId], " response for requestId has already been sent !! - Internal Error");
            this.__verifId[requestId] = requestId;
        }
        if (utils_1.doPerfMonitoring) {
            // record tick : send response received.
            this._tick2 = (0, node_opcua_utils_1.get_clock_tick)();
        }
        // istanbul ignore next
        if (!this.securityToken) {
            throw new Error("Internal error");
        }
        let options = {
            channelId: this.securityToken.channelId,
            chunkSize: this.transport.receiveBufferSize,
            requestId,
            tokenId: this.securityToken.tokenId
        };
        const securityOptions = msgType === "OPN" ? this._get_security_options_for_OPN() : this._get_security_options_for_MSG();
        if (securityOptions) {
            options = Object.assign(Object.assign({}, options), securityOptions);
        }
        response.responseHeader.requestHandle = request.requestHeader.requestHandle;
        /* istanbul ignore next */
        if (0 && doDebug) {
            // tslint:disable-next-line: no-console
            console.log(" options ", options);
            (0, node_opcua_packet_analyzer_1.analyze_object_binary_encoding)(response);
        }
        /* istanbul ignore next */
        if (utils_1.doTraceServerMessage) {
            (0, utils_1.traceResponseMessage)(response, this.securityToken.channelId, this._counter);
        }
        if (this._on_response) {
            this._on_response(msgType, response, message);
        }
        this._transactionsCount += 1;
        this.messageChunker.chunkSecureMessage(msgType, options, response, (err, messageChunk) => {
            if (err) {
                // the response would be too large !!!!
                warningLog("Error while chunking response message : ", err.message);
                this._send_chunk(callback, messageChunk);
                /* this.send_response(
                    "MSG",
                    new ServiceFault({
                        responseHeader: {
                            requestHandle: request.requestHeader.requestHandle,
                            serviceResult: StatusCodes.BadTcpMessageTooLarge
                        }
                    }),
                    message,
                    callback
                );
                */
            }
            else {
                this._send_chunk(callback, messageChunk);
            }
        });
    }
    _sendFatalErrorAndAbort(statusCode, description, message, callback) {
        this.transport.disconnect(() => {
            this.close(() => {
                callback(new Error(description + " statusCode = " + statusCode.toString()));
            });
        });
    }
    getRemoteIPAddress() {
        var _a, _b;
        return ((_b = (_a = this.transport) === null || _a === void 0 ? void 0 : _a._socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) || "";
    }
    getRemotePort() {
        var _a, _b;
        return ((_b = (_a = this.transport) === null || _a === void 0 ? void 0 : _a._socket) === null || _b === void 0 ? void 0 : _b.remotePort) || 0;
    }
    getRemoteFamily() {
        var _a, _b;
        return ((_b = (_a = this.transport) === null || _a === void 0 ? void 0 : _a._socket) === null || _b === void 0 ? void 0 : _b.remoteFamily) || "";
    }
    /**
     * Abruptly close a Server SecureChannel ,by terminating the underlying transport.
     *
     *
     * @method close
     * @async
     * @param callback
     */
    close(callback) {
        if (!this.transport) {
            if (typeof callback === "function") {
                callback();
            }
            return;
        }
        debugLog("ServerSecureChannelLayer#close");
        // close socket
        this.transport.disconnect(() => {
            this._abort();
            if (typeof callback === "function") {
                callback();
            }
        });
    }
    has_endpoint_for_security_mode_and_policy(securityMode, securityPolicy) {
        if (!this.parent) {
            return true;
        }
        const endpoint_desc = this.getEndpointDescription(securityMode, securityPolicy, null);
        return endpoint_desc !== null;
    }
    _rememberClientAddressAndPort() {
        if (this.transport && this.transport._socket) {
            this._remoteAddress = this.transport._socket.remoteAddress || "";
            this._remotePort = this.transport._socket.remotePort || 0;
        }
    }
    _stop_security_token_watch_dog() {
        if (this._securityTokenTimeout) {
            clearTimeout(this._securityTokenTimeout);
            this._securityTokenTimeout = null;
        }
    }
    _start_security_token_watch_dog() {
        // install securityToken timeout watchdog
        this._securityTokenTimeout = setTimeout(() => {
            warningLog(" Security token has really expired and shall be discarded !!!! (lifetime is = ", this.securityToken.revisedLifetime, ")");
            warningLog(" Server will now refuse message with token ", this.securityToken.tokenId);
            this._securityTokenTimeout = null;
        }, (this.securityToken.revisedLifetime * 120) / 100);
    }
    _add_new_security_token() {
        this._stop_security_token_watch_dog();
        this.lastTokenId += 1;
        this.channelId = this.__hash;
        (0, node_opcua_assert_1.assert)(this.channelId > 0);
        const securityToken = new node_opcua_service_secure_channel_1.ChannelSecurityToken({
            channelId: this.channelId,
            createdAt: new Date(),
            revisedLifetime: this.revisedLifetime,
            tokenId: this.lastTokenId // todo ?
        });
        (0, node_opcua_assert_1.assert)(!(0, node_opcua_service_secure_channel_1.hasTokenExpired)(securityToken));
        (0, node_opcua_assert_1.assert)(isFinite(securityToken.revisedLifetime));
        this.securityToken = securityToken;
        debugLog("SecurityToken", securityToken.tokenId);
        this._start_security_token_watch_dog();
    }
    _prepare_security_token(openSecureChannelRequest) {
        this.securityToken = null;
        if (openSecureChannelRequest.requestType === services_1.SecurityTokenRequestType.Renew) {
            this._stop_security_token_watch_dog();
        }
        else if (openSecureChannelRequest.requestType === services_1.SecurityTokenRequestType.Issue) {
            // TODO
        }
        else {
            // Invalid requestType
        }
        this._add_new_security_token();
    }
    _set_lifetime(requestedLifetime) {
        (0, node_opcua_assert_1.assert)(isFinite(requestedLifetime));
        // revised lifetime
        this.revisedLifetime = requestedLifetime;
        if (this.revisedLifetime === 0) {
            this.revisedLifetime = this.defaultSecureTokenLifetime;
        }
        else {
            this.revisedLifetime = Math.min(this.defaultSecureTokenLifetime, this.revisedLifetime);
            this.revisedLifetime = Math.max(ServerSecureChannelLayer.g_MinimumSecureTokenLifetime, this.revisedLifetime);
        }
        // xx console.log('requestedLifetime,self.defaultSecureTokenLifetime, self.revisedLifetime',requestedLifetime,self.defaultSecureTokenLifetime, self.revisedLifetime);
    }
    _stop_open_channel_watch_dog() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        if (this._open_secure_channel_onceClose) {
            this.transport.removeListener("close", this._open_secure_channel_onceClose);
            this._open_secure_channel_onceClose = null;
        }
    }
    _cleanup_pending_timers() {
        // there is no need for the security token expiration event to trigger anymore
        this._stop_security_token_watch_dog();
        this._stop_open_channel_watch_dog();
    }
    _cancel_wait_for_open_secure_channel_request_timeout() {
        this._stop_open_channel_watch_dog();
    }
    _install_wait_for_open_secure_channel_request_timeout(callback, timeout) {
        (0, node_opcua_assert_1.assert)(isFinite(timeout));
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        this._open_secure_channel_onceClose = (err) => {
            this._open_secure_channel_onceClose = null;
            this._stop_open_channel_watch_dog();
            this.close(() => {
                const err = new Error("Timeout waiting for OpenChannelRequest (A) (timeout was " + timeout + " ms)");
                callback(err);
            });
        };
        this.transport.prependOnceListener("close", this._open_secure_channel_onceClose);
        this.timeoutId = setTimeout(() => {
            this.timeoutId = null;
            this._stop_open_channel_watch_dog();
            const err = new Error("Timeout waiting for OpenChannelRequest (B) (timeout was " + timeout + " ms)");
            debugLog(err.message);
            this.close(() => {
                callback(err);
            });
        }, timeout);
    }
    _on_initial_open_secure_channel_request(callback, request, msgType, requestId, channelId) {
        /* istanbul ignore next */
        if (utils_1.doTraceServerMessage) {
            (0, utils_1.traceRequestMessage)(request, channelId, this._counter);
        }
        /* istanbul ignore next */
        if (!(this.messageBuilder && this.messageBuilder.sequenceHeader && this.messageBuilder.securityHeader)) {
            return this._on_OpenSecureChannelRequestError(node_opcua_status_code_1.StatusCodes.BadCommunicationError, "internal error", { request, requestId }, callback);
        }
        const message = {
            request,
            requestId,
            securityHeader: this.messageBuilder.securityHeader
        };
        requestId = this.messageBuilder.sequenceHeader.requestId;
        if (requestId < 0) {
            return this._on_OpenSecureChannelRequestError(node_opcua_status_code_1.StatusCodes.BadCommunicationError, "Invalid requestId", message, callback);
        }
        this.clientSecurityHeader = message.securityHeader;
        let description;
        // expecting a OpenChannelRequest as first communication message
        if (!(request instanceof services_1.OpenSecureChannelRequest)) {
            description = "Expecting OpenSecureChannelRequest";
            warningLog(chalk.red("ERROR"), "BadCommunicationError: expecting a OpenChannelRequest as first communication message");
            return this._on_OpenSecureChannelRequestError(node_opcua_status_code_1.StatusCodes.BadCommunicationError, description, message, callback);
        }
        // check that the request is a OpenSecureChannelRequest
        /* istanbul ignore next */
        if (doDebug) {
            debugLog(this.messageBuilder.sequenceHeader.toString());
            debugLog(this.messageBuilder.securityHeader.toString());
        }
        const asymmetricSecurityHeader = this.messageBuilder.securityHeader;
        const securityPolicy = message.securityHeader
            ? (0, security_policy_1.fromURI)(asymmetricSecurityHeader.securityPolicyUri)
            : security_policy_1.SecurityPolicy.Invalid;
        // check security header
        const securityPolicyStatus = isValidSecurityPolicy(securityPolicy);
        if (securityPolicyStatus !== node_opcua_status_code_1.StatusCodes.Good) {
            description = " Unsupported securityPolicyUri " + asymmetricSecurityHeader.securityPolicyUri;
            warningLog("BadSecurityPolicyRejected: Unsupported securityPolicyUri", securityPolicy);
            return this._on_OpenSecureChannelRequestError(securityPolicyStatus, description, message, callback);
        }
        // check certificate
        this.securityMode = request.securityMode;
        this.securityPolicy = securityPolicy;
        this.messageBuilder.securityMode = this.securityMode;
        const hasEndpoint = this.has_endpoint_for_security_mode_and_policy(this.securityMode, securityPolicy);
        if (!hasEndpoint) {
            // there is no
            description = " This server doesn't not support  " + securityPolicy.toString() + " " + this.securityMode.toString();
            return this._on_OpenSecureChannelRequestError(node_opcua_status_code_1.StatusCodes.BadSecurityPolicyRejected, description, message, callback);
        }
        this.messageBuilder
            .on("message", (request, msgType, requestId, channelId) => {
            this._on_common_message(request, msgType, requestId, channelId);
        })
            .on("error", (err, statusCode, requestId) => {
            /** */
            this.transport.sendErrorMessage(statusCode, err.message);
            this.close();
        })
            .on("startChunk", () => {
            if (utils_1.doPerfMonitoring) {
                // record tick 0: when the first chunk is received
                this._tick0 = (0, node_opcua_utils_1.get_clock_tick)();
            }
        });
        // handle initial OpenSecureChannelRequest
        this._process_certificates(message, (err, statusCode) => {
            // istanbul ignore next
            if (err || !statusCode) {
                description = "Internal Error " + (err === null || err === void 0 ? void 0 : err.message);
                return this._on_OpenSecureChannelRequestError(node_opcua_status_code_1.StatusCodes.BadInternalError, description, message, callback);
            }
            if (statusCode.isNotGood()) {
                const description = "Sender Certificate Error";
                debugLog(chalk.cyan(description), chalk.bgCyan.yellow(statusCode.toString()));
                // OPCUA specification v1.02 part 6 page 42 $6.7.4
                // If an error occurs after the  Server  has verified  Message  security  it  shall  return a  ServiceFault  instead
                // of a OpenSecureChannel  response. The  ServiceFault  Message  is described in  Part  4,   7.28.
                if (statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateIssuerRevocationUnknown) &&
                    statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateRevocationUnknown) &&
                    statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateTimeInvalid) &&
                    statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateUseNotAllowed)) {
                    statusCode = node_opcua_status_code_1.StatusCodes.BadSecurityChecksFailed;
                }
                return this._on_OpenSecureChannelRequestError(statusCode, description, message, callback);
            }
            this._handle_OpenSecureChannelRequest(statusCode, message, callback);
        });
    }
    _wait_for_open_secure_channel_request(callback, timeout) {
        this._install_wait_for_open_secure_channel_request_timeout(callback, timeout);
        const errorHandler = (err) => {
            this._cancel_wait_for_open_secure_channel_request_timeout();
            if (this.messageBuilder) {
                this.messageBuilder.removeListener("message", messageHandler);
                this.close(() => {
                    callback(new Error("/Expecting OpenSecureChannelRequest to be valid " + err.message));
                });
            }
        };
        const messageHandler = (request, msgType, requestId, channelId) => {
            this._cancel_wait_for_open_secure_channel_request_timeout();
            this.messageBuilder.removeListener("error", errorHandler);
            this._on_initial_open_secure_channel_request(callback, request, msgType, requestId, channelId);
        };
        this.messageBuilder.prependOnceListener("error", errorHandler);
        this.messageBuilder.once("message", messageHandler);
    }
    _send_chunk(callback, messageChunk) {
        if (messageChunk) {
            this.transport.write(messageChunk);
        }
        else {
            if (utils_1.doPerfMonitoring) {
                // record tick 3 : transaction completed.
                this._tick3 = (0, node_opcua_utils_1.get_clock_tick)();
            }
            if (callback) {
                setImmediate(callback);
            }
            /* istanbul ignore next */
            if (utils_1.doPerfMonitoring) {
                this._record_transaction_statistics();
                // dump some statistics about transaction ( time and sizes )
                (0, utils_1._dump_transaction_statistics)(this.last_transaction_stats);
            }
            this.emit("transaction_done");
        }
    }
    _get_security_options_for_OPN() {
        // install sign & sign-encrypt behavior
        if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.Sign || this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.SignAndEncrypt) {
            const cryptoFactory = this.messageBuilder.cryptoFactory;
            /* istanbul ignore next */
            if (!cryptoFactory) {
                throw new Error("Internal Error");
            }
            (0, node_opcua_assert_1.assert)(cryptoFactory, "ServerSecureChannelLayer must have a crypto strategy");
            (0, node_opcua_assert_1.assert)(this.receiverPublicKeyLength >= 0);
            const receiverPublicKey = this.receiverPublicKey;
            if (!receiverPublicKey) {
                // this could happen if certificate was wrong
                // throw new Error("Invalid receiverPublicKey");
                return null;
            }
            const options = {
                cipherBlockSize: this.receiverPublicKeyLength,
                plainBlockSize: this.receiverPublicKeyLength - cryptoFactory.blockPaddingSize,
                signatureLength: this.getSignatureLength(),
                encryptBufferFunc: (chunk) => {
                    return cryptoFactory.asymmetricEncrypt(chunk, receiverPublicKey);
                },
                signBufferFunc: (chunk) => {
                    const signed = cryptoFactory.asymmetricSign(chunk, this.getPrivateKey());
                    (0, node_opcua_assert_1.assert)(signed.length === options.signatureLength);
                    return signed;
                }
            };
            return options; // partial
        }
        return null;
    }
    _get_security_options_for_MSG() {
        if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            return null;
        }
        const cryptoFactory = this.messageBuilder.cryptoFactory;
        /* istanbul ignore next */
        if (!cryptoFactory || !this.derivedKeys) {
            return null;
        }
        (0, node_opcua_assert_1.assert)(cryptoFactory, "ServerSecureChannelLayer must have a crypto strategy");
        (0, node_opcua_assert_1.assert)(this.derivedKeys.derivedServerKeys);
        const derivedServerKeys = this.derivedKeys.derivedServerKeys;
        if (!derivedServerKeys) {
            return null;
        }
        return (0, security_policy_1.getOptionsForSymmetricSignAndEncrypt)(this.securityMode, derivedServerKeys);
    }
    /**
     * _process_certificates extracts client public keys from client certificate
     *  and store them in self.receiverPublicKey and self.receiverCertificate
     *  it also caches self.receiverPublicKeyLength.
     *
     *  so they can be used by security channel.
     *
     * @method _process_certificates
     * @param message the message coming from the client
     * @param callback
     * @private
     * @async
     */
    _process_certificates(message, callback) {
        const asymmSecurityHeader = message.securityHeader;
        // verify certificate
        const certificate = asymmSecurityHeader ? asymmSecurityHeader.senderCertificate : null;
        this.checkCertificateCallback(certificate, (err, statusCode) => {
            if (err) {
                return callback(err);
            }
            //
            this.receiverPublicKey = null;
            this.receiverPublicKeyLength = 0;
            this.receiverCertificate = asymmSecurityHeader ? asymmSecurityHeader.senderCertificate : null;
            // get the clientCertificate for convenience
            this.clientCertificate = this.receiverCertificate;
            // ignore receiverCertificate that have a zero length
            /* istanbul ignore next */
            if (this.receiverCertificate && this.receiverCertificate.length === 0) {
                this.receiverCertificate = null;
            }
            if (this.receiverCertificate) {
                // extract public key
                (0, node_opcua_crypto_1.extractPublicKeyFromCertificate)(this.receiverCertificate, (err, keyPem) => {
                    if (!err) {
                        if (keyPem) {
                            this.receiverPublicKey = crypto.createPublicKey(keyPem);
                            this.receiverPublicKeyLength = (0, node_opcua_crypto_1.rsaLengthPublicKey)(keyPem);
                        }
                        callback(null, statusCode);
                    }
                    else {
                        callback(err);
                    }
                });
            }
            else {
                this.receiverPublicKey = null;
                callback(null, statusCode);
            }
        });
    }
    _prepare_security_header(request, message) {
        let securityHeader;
        // senderCertificate:
        //    The X509v3 certificate assigned to the sending application instance.
        //    This is a DER encoded blob.
        //    This indicates what private key was used to sign the MessageChunk.
        //    This field shall be null if the message is not signed.
        // receiverCertificateThumbprint:
        //    The thumbprint of the X509v3 certificate assigned to the receiving application
        //    The thumbprint is the SHA1 digest of the DER encoded form of the certificate.
        //    This indicates what public key was used to encrypt the MessageChunk
        //   This field shall be null if the message is not encrypted.
        switch (request.securityMode) {
            case node_opcua_service_secure_channel_1.MessageSecurityMode.None:
                securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
                    receiverCertificateThumbprint: null,
                    securityPolicyUri: "http://opcfoundation.org/UA/SecurityPolicy#None",
                    senderCertificate: null // message not signed
                });
                break;
            case node_opcua_service_secure_channel_1.MessageSecurityMode.Sign:
            case node_opcua_service_secure_channel_1.MessageSecurityMode.SignAndEncrypt:
            default: {
                if (!this.parent) {
                    warningLog("Cannot find parent of SecureChannel !!!!!!!! ");
                    return null;
                }
                const receiverCertificateThumbprint = (0, common_1.getThumbprint)(this.receiverCertificate);
                const asymmClientSecurityHeader = this.clientSecurityHeader;
                // istanbul ignore next
                securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
                    receiverCertificateThumbprint,
                    securityPolicyUri: asymmClientSecurityHeader.securityPolicyUri,
                    /**
                     * The X.509 v3 Certificate assigned to the sending application Instance.
                     *  This is a DER encoded blob.
                     * The structure of an X.509 v3 Certificate is defined in X.509 v3.
                     * The DER format for a Certificate is defined in X690
                     * This indicates what Private Key was used to sign the MessageChunk.
                     * The Stack shall close the channel and report an error to the application if the SenderCertificate is too large for the buffer size supported by the transport layer.
                     * This field shall be null if the Message is not signed.
                     * If the Certificate is signed by a CA, the DER encoded CA Certificate may be
                     * appended after the Certificate in the byte array. If the CA Certificate is also
                     * signed by another CA this process is repeated until the entire Certificate chain
                     *  is in the buffer or if MaxSenderCertificateSize limit is reached (the process
                     * stops after the last whole Certificate that can be added without exceeding
                     * the MaxSenderCertificateSize limit).
                     * Receivers can extract the Certificates from the byte array by using the Certificate
                     *  size contained in DER header (see X.509 v3).
                     */
                    senderCertificate: this.getCertificateChain() // certificate of the private key used to sign the message
                });
            }
        }
        return securityHeader;
    }
    checkCertificateCallback(certificate, callback) {
        /** */
    }
    checkCertificate(certificate) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (!certificate) {
                return node_opcua_status_code_1.StatusCodes.Good;
            }
            // istanbul ignore next
            if (!this.certificateManager) {
                return node_opcua_status_code_1.StatusCodes.BadInternalError;
            }
            const statusCode = yield this.certificateManager.checkCertificate(certificate);
            if (statusCode.isGood()) {
                const certInfo = (0, node_opcua_crypto_1.exploreCertificate)(certificate);
                if (!((_b = (_a = certInfo.tbsCertificate.extensions) === null || _a === void 0 ? void 0 : _a.keyUsage) === null || _b === void 0 ? void 0 : _b.dataEncipherment)) {
                    return node_opcua_status_code_1.StatusCodes.BadCertificateUseNotAllowed;
                }
                if (!((_d = (_c = certInfo.tbsCertificate.extensions) === null || _c === void 0 ? void 0 : _c.keyUsage) === null || _d === void 0 ? void 0 : _d.digitalSignature)) {
                    return node_opcua_status_code_1.StatusCodes.BadCertificateUseNotAllowed;
                }
            }
            return statusCode;
        });
    }
    _handle_OpenSecureChannelRequest(serviceResult, message, callback) {
        const request = message.request;
        const requestId = message.requestId;
        if (!(requestId !== 0 && requestId > 0)) {
            warningLog("OpenSecureChannelRequest: requestId");
            return this._sendFatalErrorAndAbort(node_opcua_transport_1.StatusCodes2.BadTcpInternalError, "invalid request", message, callback);
        }
        // let prepare self.securityHeader;
        this.securityHeader = this._prepare_security_header(request, message);
        /* istanbul ignore next */
        if (!this.securityHeader) {
            warningLog("Cannot find SecurityHeader !!!!!!!! ");
            return this._sendFatalErrorAndAbort(node_opcua_transport_1.StatusCodes2.BadSecurityChecksFailed, "invalid request", message, callback);
        }
        this.clientNonce = request.clientNonce;
        if (nonceAlreadyBeenUsed(this.clientNonce)) {
            warningLog(chalk.red("SERVER with secure connection: Nonce has already been used"), this.clientNonce.toString("hex"));
            serviceResult = node_opcua_status_code_1.StatusCodes.BadNonceInvalid;
        }
        this._set_lifetime(request.requestedLifetime);
        this._prepare_security_token(request);
        const cryptoFactory = this.messageBuilder.cryptoFactory;
        if (cryptoFactory) {
            // serverNonce: A random number that shall not be used in any other request. A new
            //    serverNonce shall be generated for each time a SecureChannel is renewed.
            //    This parameter shall have a length equal to key size used for the symmetric
            //    encryption algorithm that is identified by the securityPolicyUri.
            this.serverNonce = crypto.randomBytes(cryptoFactory.symmetricKeyLength);
            if (this.clientNonce.length !== this.serverNonce.length) {
                warningLog(chalk.red("warning client Nonce length doesn't match server nonce length"), this.clientNonce.length, " !== ", this.serverNonce.length);
                // what can we do
                // - just ignore it ?
                // - or adapt serverNonce length to clientNonce Length ?
                // xx self.serverNonce = crypto.randomBytes(self.clientNonce.length);
                // - or adapt clientNonce length to serverNonce Length ?
                // xx self.clientNonce = self.clientNonce.subarray(0,self.serverNonce.length);
                //
                // - or abort connection ? << LET BE SAFE AND CHOOSE THIS ONE !
                serviceResult = node_opcua_status_code_1.StatusCodes.BadSecurityModeRejected; // ToDo check code
            }
            // expose derivedKey to use for symmetric sign&encrypt
            // to help us decrypting and verifying messages received from client
            this.derivedKeys = (0, security_policy_1.computeDerivedKeys)(cryptoFactory, this.serverNonce, this.clientNonce);
        }
        const derivedClientKeys = this.derivedKeys ? this.derivedKeys.derivedClientKeys : null;
        this.messageBuilder.pushNewToken(this.securityToken, derivedClientKeys);
        const derivedServerKeys = this.derivedKeys ? this.derivedKeys.derivedServerKeys : undefined;
        this.messageChunker.update({
            // for OPN
            securityHeader: this.securityHeader,
            // derived keys for symmetric encryption of standard MSG
            // to sign and encrypt MSG sent to client
            derivedKeys: derivedServerKeys
        });
        let description;
        // If the SecurityMode is not None then the Server shall verify that a SenderCertificate and a
        // ReceiverCertificateThumbprint were specified in the SecurityHeader.
        if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            /* istanbul ignore next */
            if (!this.clientSecurityHeader) {
                throw new Error("Internal Error");
            }
            if (!this._check_receiverCertificateThumbprint(this.clientSecurityHeader)) {
                description =
                    "Server#OpenSecureChannelRequest : Invalid receiver certificate thumbprint : the thumbprint doesn't match server certificate !";
                warningLog(chalk.cyan(description));
                serviceResult = node_opcua_status_code_1.StatusCodes.BadCertificateInvalid;
            }
        }
        const response = new services_1.OpenSecureChannelResponse({
            responseHeader: { serviceResult },
            securityToken: this.securityToken,
            serverNonce: this.serverNonce || undefined,
            serverProtocolVersion: this.protocolVersion
        });
        if (utils_1.doTraceServerMessage) {
            console.log("Transport maxMessageSize = ", this.transport.maxMessageSize);
            console.log("Transport maxChunkCount = ", this.transport.maxChunkCount);
        }
        this.send_response("OPN", response, message, ( /*err*/) => {
            const responseHeader = response.responseHeader;
            if (responseHeader.serviceResult !== node_opcua_status_code_1.StatusCodes.Good) {
                warningLog("OpenSecureChannelRequest Closing communication ", responseHeader.serviceResult.toString());
                this.close();
            }
            callback();
        });
    }
    _abort() {
        debugLog("ServerSecureChannelLayer#_abort");
        if (this._abort_has_been_called) {
            debugLog("Warning => ServerSecureChannelLayer#_abort has already been called");
            return;
        }
        ServerSecureChannelLayer.registry.unregister(this);
        this._abort_has_been_called = true;
        this._cleanup_pending_timers();
        /**
         * notify the observers that the SecureChannel has aborted.
         * the reason could be :
         *   - a CloseSecureChannelRequest has been received.
         *   - a invalid message has been received
         * the event is sent after the underlying transport layer has been closed.
         *
         * @event abort
         */
        this.emit("abort");
        debugLog("ServerSecureChannelLayer emitted abort event");
    }
    _record_transaction_statistics() {
        this._bytesRead_before = this._bytesRead_before || 0;
        this._bytesWritten_before = this._bytesWritten_before || 0;
        this.last_transaction_stats = {
            bytesRead: this.bytesRead - this._bytesRead_before,
            bytesWritten: this.bytesWritten - this._bytesWritten_before,
            lap_reception: this._tick1 - this._tick0,
            lap_processing: this._tick2 - this._tick1,
            lap_emission: this._tick3 - this._tick2
        };
        // final operation in statistics
        this._bytesRead_before = this.bytesRead;
        this._bytesWritten_before = this.bytesWritten;
    }
    _on_common_message(request, msgType, requestId, channelId) {
        /* istanbul ignore next */
        if (utils_1.doTraceServerMessage) {
            (0, utils_1.traceRequestMessage)(request, channelId, this._counter);
        }
        /* istanbul ignore next */
        if (this.messageBuilder.sequenceHeader === null) {
            throw new Error("Internal Error");
        }
        requestId = this.messageBuilder.sequenceHeader.requestId;
        const message = {
            channel: this,
            request,
            requestId
        };
        if (msgType === "CLO" && request.schema.name === "CloseSecureChannelRequest") {
            this.close();
        }
        else if (msgType === "OPN" && request.schema.name === "OpenSecureChannelRequest") {
            // intercept client request to renew security Token
            this._handle_OpenSecureChannelRequest(node_opcua_status_code_1.StatusCodes.Good, message, ( /* err?: Error*/) => {
                /** */
            });
        }
        else {
            if (request.schema.name === "CloseSecureChannelRequest") {
                warningLog("WARNING : RECEIVED a CloseSecureChannelRequest with msgType=", msgType);
                this.close();
            }
            else {
                if (utils_1.doPerfMonitoring) {
                    // record tick 1 : after message has been received, before message processing
                    this._tick1 = (0, node_opcua_utils_1.get_clock_tick)();
                }
                if (this.securityToken && channelId !== this.securityToken.channelId) {
                    // response = new ServiceFault({responseHeader: {serviceResult: certificate_status}});
                    debugLog("Invalid channelId detected =", channelId, " <> ", this.securityToken.channelId);
                    return this._sendFatalErrorAndAbort(node_opcua_status_code_1.StatusCodes.BadCommunicationError, "Invalid Channel Id specified " + this.securityToken.channelId, message, () => {
                        /** */
                    });
                }
                /**
                 * notify the observer that a OPCUA message has been received.
                 * It is up to one observer to call send_response or _send_ServiceFault_and_abort to complete
                 * the transaction.
                 *
                 * @event message
                 * @param message
                 */
                this.emit("message", message);
            }
        }
    }
    /**
     * @method _check_receiverCertificateThumbprint
     * verify that the receiverCertificateThumbprint send by the client
     * matching the CertificateThumbPrint of the server
     * @param clientSecurityHeader
     * @return true if the receiver certificate thumbprint matches the server certificate
     * @private
     */
    _check_receiverCertificateThumbprint(clientSecurityHeader) {
        if (clientSecurityHeader instanceof node_opcua_service_secure_channel_1.SymmetricAlgorithmSecurityHeader) {
            return true; // nothing we can do here
        }
        if (clientSecurityHeader.receiverCertificateThumbprint) {
            // check if the receiverCertificateThumbprint is my certificate thumbprint
            const serverCertificate = this.getCertificate();
            const myCertificateThumbPrint = (0, node_opcua_crypto_1.makeSHA1Thumbprint)(serverCertificate);
            const thisIsMyCertificate = myCertificateThumbPrint.toString("hex") === clientSecurityHeader.receiverCertificateThumbprint.toString("hex");
            if (doDebug && !thisIsMyCertificate) {
                debugLog("receiverCertificateThumbprint do not match server certificate", myCertificateThumbPrint.toString("hex") +
                    " <> " +
                    clientSecurityHeader.receiverCertificateThumbprint.toString("hex"));
            }
            return thisIsMyCertificate;
        }
        return true;
    }
    // Bad_CertificateHostNameInvalid            The HostName used to connect to a Server does not match a HostName in the
    //                                           Certificate.
    // Bad_CertificateIssuerRevocationUnknown    It was not possible to determine if the Issuer Certificate has been revoked.
    // Bad_CertificateIssuerUseNotAllowed        The Issuer Certificate may not be used for the requested operation.
    // Bad_CertificateIssuerTimeInvalid          An Issuer Certificate has expired or is not yet valid.
    // Bad_CertificateIssuerRevoked              The Issuer Certificate has been revoked.
    // Bad_CertificateInvalid                    The certificate provided as a parameter is not valid.
    // Bad_CertificateRevocationUnknown          It was not possible to determine if the Certificate has been revoked.
    // Bad_CertificateRevoked                    The Certificate has been revoked.
    // Bad_CertificateTimeInvalid                The Certificate has expired or is not yet valid.
    // Bad_CertificateUriInvalid                 The URI specified in the ApplicationDescription does not match the URI in the Certificate.
    // Bad_CertificateUntrusted                  The Certificate is not trusted.
    // Bad_CertificateUseNotAllowed              The Certificate may not be used for the requested operation.
    // Bad_RequestTypeInvalid     The security token request type is not valid.
    // Bad_SecurityModeRejected   The security mode does not meet the requirements set by the Server.
    // Bad_SecurityPolicyRejected The security policy does not meet the requirements set by the Server.
    // Bad_SecureChannelIdInvalid
    // Bad_NonceInvalid
    _on_OpenSecureChannelRequestError(serviceResult, description, message, callback) {
        debugLog("ServerSecureChannel sendError: ", serviceResult.toString(), description, message.request.constructor.name);
        // turn of security mode as we haven't manage to set it to
        this.securityMode = node_opcua_service_secure_channel_1.MessageSecurityMode.None;
        // setTimeout(() => {
        this._sendFatalErrorAndAbort(serviceResult, description, message, callback);
        // }, ServerSecureChannelLayer.throttleTime); // Throttling keep connection on hold for a while.
    }
}
ServerSecureChannelLayer.throttleTime = 100;
ServerSecureChannelLayer.g_MinimumSecureTokenLifetime = 2500;
ServerSecureChannelLayer.g_counter = 0;
ServerSecureChannelLayer.registry = new node_opcua_object_registry_1.ObjectRegistry();
exports.ServerSecureChannelLayer = ServerSecureChannelLayer;
ServerSecureChannelLayer.prototype.checkCertificateCallback = (0, util_1.callbackify)(ServerSecureChannelLayer.prototype.checkCertificate);
//# sourceMappingURL=server_secure_channel_layer.js.map