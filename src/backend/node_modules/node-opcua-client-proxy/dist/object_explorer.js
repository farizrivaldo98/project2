"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readUAStructure = exports.ObjectExplorer = void 0;
/**
 * @module node-opcua-client-proxy
 */
const async = require("async");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_service_call_1 = require("node-opcua-service-call");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_debug_1 = require("node-opcua-debug");
const proxy_1 = require("./proxy");
const proxy_variable_1 = require("./proxy_variable");
const node_opcua_constants_1 = require("node-opcua-constants");
const doDebug = false;
const errorLog = (0, node_opcua_debug_1.make_errorLog)("Proxy");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("Proxy");
const resultMask = (0, node_opcua_data_model_1.makeResultMask)("ReferenceType | IsForward | BrowseName | NodeClass | TypeDefinition");
/**
 * @method convertNodeIdToDataTypeAsync
 *
 * @param session
 * @param dataTypeId
 * @param callback
 * @param callback.err
 * @param callback.dataType
 *
 *  @example
 *
 *      const dataTypeId  ="ns=0;i=11"; // Double
 *      convertNodeIdToDataTypeAsync(session,dataTypeId,function(err,dataType) {
 *          assert(!err && dataType === DataType.Double);
 *      });
 *
 *      const dataTypeId  ="ns=0;i=290"; // Duration => SubTypeOf Double
 *      convertNodeIdToDataTypeAsync(session,dataTypeId,function(err,dataType) {
 *          assert(!err && dataType === DataType.Double);
 *      });
 *
 * see also AddressSpace#findCorrespondingBasicDataType
 *
 * for an enumeration dataType will be DataType.Int32
 */
function convertNodeIdToDataTypeAsync(session, dataTypeId, callback) {
    const nodeToRead = {
        attributeId: node_opcua_data_model_1.AttributeIds.BrowseName,
        nodeId: dataTypeId
    };
    session.read(nodeToRead, (err, dataValue) => {
        // istanbul ignore next
        if (err) {
            setImmediate(() => {
                callback(err);
            });
            return;
        }
        dataValue = dataValue;
        let dataType;
        // istanbul ignore next
        if (dataValue.statusCode.isNotGood()) {
            dataType = node_opcua_variant_1.DataType.Null;
            setImmediate(() => {
                callback(null, dataType);
            });
            return;
        }
        const dataTypeName = dataValue.value.value;
        if (dataTypeId.namespace === 0 && dataTypeId.value === node_opcua_constants_1.DataTypeIds.Enumeration) {
            dataType = node_opcua_variant_1.DataType.Int32;
            setImmediate(() => {
                callback(null, dataType);
            });
            return;
        }
        if (dataTypeId.namespace === 0 && node_opcua_variant_1.DataType[dataTypeId.value]) {
            dataType = node_opcua_variant_1.DataType[dataTypeId.value];
            setImmediate(() => {
                callback(null, dataType);
            });
            return;
        }
        /// example => Duration (i=290) => Double (i=11)
        // read subTypeOf
        const nodeToBrowse = {
            browseDirection: node_opcua_data_model_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeId: dataTypeId,
            // BrowseDescription
            referenceTypeId: (0, proxy_1.makeRefId)("HasSubtype"),
            // xx nodeClassMask: makeNodeClassMask("ObjectType"),
            resultMask
        };
        // tslint:disable:no-shadowed-variable
        session.browse(nodeToBrowse, (err, browseResult) => {
            // istanbul ignore next
            if (err) {
                return callback(err);
            }
            const references = browseResult.references;
            if (!references || references.length !== 1) {
                return callback(new Error("cannot find SuperType of " + dataTypeName.toString()));
            }
            const nodeId = references[0].nodeId;
            return convertNodeIdToDataTypeAsync(session, nodeId, callback);
        });
    });
}
function convertToVariant(value, arg, propName) {
    const dataType = arg._basicDataType || node_opcua_variant_1.DataType.Null;
    const arrayType = arg.valueRank === 1 ? node_opcua_variant_1.VariantArrayType.Array : arg.valueRank === -1 ? node_opcua_variant_1.VariantArrayType.Scalar : node_opcua_variant_1.VariantArrayType.Matrix;
    if (value === undefined) {
        throw new Error("expecting input argument ");
    }
    if (arrayType === node_opcua_variant_1.VariantArrayType.Array) {
        if (!Array.isArray(value)) {
            throw new Error("expecting value to be an Array or a TypedArray");
        }
    }
    return new node_opcua_variant_1.Variant({ arrayType, dataType, value });
}
function convertToVariantArray(inputArgsDef, inputArgs) {
    const inputArguments = inputArgsDef.map((arg) => {
        const propName = (0, node_opcua_utils_1.lowerFirstLetter)(arg.name || "");
        const value = inputArgs[propName];
        return convertToVariant(value, arg, propName);
    });
    return inputArguments;
}
const thenify = require("thenify");
function makeFunction(obj, methodName) {
    return thenify.withCallback(function functionCaller(inputArgs, callback) {
        const session = this.proxyManager.session;
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        const methodDef = this.$methods[methodName];
        // convert input arguments into Variants
        const inputArgsDef = methodDef.inputArguments || [];
        const inputArguments = convertToVariantArray(inputArgsDef, inputArgs);
        const methodToCall = new node_opcua_service_call_1.CallMethodRequest({
            inputArguments,
            methodId: methodDef.nodeId,
            objectId: obj.nodeId
        });
        session.call(methodToCall, (err, callResult) => {
            // istanbul ignore next
            if (err) {
                return callback(err);
            }
            callResult = callResult;
            if (callResult.statusCode.isNotGood()) {
                return callback(new Error("Error " + callResult.statusCode.toString()));
            }
            callResult.outputArguments = callResult.outputArguments || [];
            if (callResult.outputArguments.length !== methodDef.outputArguments.length) {
                return callback(new Error("Internal error callResult.outputArguments.length " +
                    callResult.outputArguments.length +
                    " " +
                    obj[methodName].outputArguments.length));
            }
            const output = {};
            methodDef.outputArguments.map((arg, index) => {
                const variant = callResult.outputArguments[index];
                const propName = (0, node_opcua_utils_1.lowerFirstLetter)(arg.name);
                output[propName] = variant.value;
            });
            callback(err, output);
        });
    });
}
function extractDataType(session, arg, callback) {
    if (arg.dataType && arg._basicDataType) {
        setImmediate(callback); // already converted
        return;
    }
    convertNodeIdToDataTypeAsync(session, arg.dataType, (err, dataType) => {
        if (!err) {
            arg._basicDataType = dataType;
        }
        callback(err || undefined);
    });
}
/**
 * @method add_method
 * @private
 */
function add_method(proxyManager, obj, reference, outerCallback) {
    const session = proxyManager.session;
    const methodName = (0, node_opcua_utils_1.lowerFirstLetter)(reference.browseName.name);
    let inputArguments = [];
    let outputArguments = [];
    // tslint:disable:no-shadowed-variable
    async.series([
        (callback) => {
            session.getArgumentDefinition(reference.nodeId, (err, argumentDefinition) => {
                // istanbul ignore next
                if (err) {
                    errorLog("getArgumentDefinition failed ", err);
                    return callback(err);
                }
                // istanbul ignore next
                if (!argumentDefinition) {
                    return callback(new Error("Internal Error"));
                }
                inputArguments = argumentDefinition.inputArguments || [];
                outputArguments = argumentDefinition.outputArguments || [];
                const _extractDataType = extractDataType.bind(null, session);
                async.series([
                    (innerCallback) => async.eachSeries(inputArguments, _extractDataType, innerCallback),
                    (innerCallback) => async.eachSeries(outputArguments, _extractDataType, innerCallback)
                ], (err) => callback(err));
            });
        },
        (callback) => {
            const methodObj = {
                browseName: methodName,
                executableFlag: false,
                func: makeFunction(obj, methodName),
                nodeId: reference.nodeId,
                inputArguments,
                outputArguments
            };
            obj.$methods[methodName] = methodObj;
            obj[methodName] = methodObj.func;
            obj[methodName].inputArguments = inputArguments;
            obj[methodName].outputArguments = outputArguments;
            doDebug && debugLog("installing method name", methodName);
            proxyManager._monitor_execution_flag(methodObj, () => {
                callback();
            });
        }
    ], (err) => {
        if (err) {
            errorLog("Error =>", err);
        }
        outerCallback(err);
    });
}
function add_component(proxyManager, obj, reference, callback) {
    const session = proxyManager.session;
    const name = (0, node_opcua_utils_1.lowerFirstLetter)(reference.browseName.name || "");
    proxyManager.getObject(reference.nodeId, (err, childObj) => {
        // istanbul ignore else
        if (!err) {
            childObj = new ObjectExplorer({
                name,
                nodeId: reference.nodeId,
                parent: obj,
                proxyManager
            });
            obj[name] = childObj;
            obj.$components.push(childObj);
            childObj.$resolve(callback);
        }
        else {
            callback(err);
        }
    });
}
function addFolderElement(proxyManager, obj, reference, callback) {
    const session = proxyManager.session;
    const name = (0, node_opcua_utils_1.lowerFirstLetter)(reference.browseName.name || "");
    const childObj = new ObjectExplorer({
        name,
        nodeId: reference.nodeId,
        parent: obj,
        proxyManager
    });
    obj[name] = childObj;
    obj.$organizes.push(childObj);
    childObj.$resolve(callback);
}
function add_property(proxyManager, obj, reference, callback) {
    const session = proxyManager.session;
    const name = (0, node_opcua_utils_1.lowerFirstLetter)(reference.browseName.name || "");
    obj[name] = new proxy_variable_1.ProxyVariable(proxyManager, reference.nodeId, reference);
    obj.$properties[name] = obj[name];
    setImmediate(callback);
}
function add_typeDefinition(proxyManager, obj, references, callback) {
    const session = proxyManager.session;
    references = references || [];
    if (references.length !== 1) {
        setImmediate(callback);
        return;
    }
    const reference = references[0];
    (0, node_opcua_assert_1.assert)(!obj.typeDefinition, "type definition can only be set once");
    obj.typeDefinition = reference.browseName.name || "";
    setImmediate(callback);
}
function addFromState(proxyManager, obj, reference, callback) {
    proxyManager.getObject(reference.nodeId, (err, childObj) => {
        if (err) {
            callback(err);
        }
        obj.$fromState = childObj;
        callback();
    });
}
function addToState(proxyManager, obj, reference, callback) {
    proxyManager.getObject(reference.nodeId, (err, childObj) => {
        if (err) {
            callback(err);
        }
        obj.$toState = childObj;
        callback();
    });
}
class ObjectExplorer {
    constructor(options) {
        this.proxyManager = options.proxyManager;
        this.name = options.name;
        this.nodeId = options.nodeId;
        this.parent = options.parent;
    }
    $resolve(callback) {
        this.proxyManager.getObject(this.nodeId, (err, childObj) => {
            // istanbul ignore next
            if (err) {
                return callback(err);
            }
            this.parent[this.name] = childObj;
            this.parent.$components.push(childObj);
            callback();
        });
    }
}
exports.ObjectExplorer = ObjectExplorer;
function t(references) {
    if (!references)
        return "";
    return references.map((r) => r.browseName.name + " " + r.nodeId.toString());
}
function readUAStructure(proxyManager, obj, callback) {
    const session = proxyManager.session;
    //   0   Object
    //   1   Variable
    //   2   Method
    const nodeId = obj.nodeId;
    const nodesToBrowse = [
        // Components (except Methods)
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeClassMask: (0, node_opcua_data_model_1.makeNodeClassMask)("Object | Variable"),
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("HasComponent"),
            resultMask
        },
        // Properties
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            // nodeClassMask: makeNodeClassMask("Variable"),
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("HasProperty"),
            resultMask
        },
        // Methods
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeClassMask: (0, node_opcua_data_model_1.makeNodeClassMask)("Method"),
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("HasComponent"),
            resultMask
        },
        // TypeDefinition
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Both,
            includeSubtypes: true,
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("HasTypeDefinition"),
            resultMask
        },
        // FromState
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("FromState"),
            resultMask
        },
        // ToState
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("ToState"),
            resultMask
        },
        // (for folders ) Organizes
        {
            // BrowseDescription
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeId,
            referenceTypeId: (0, proxy_1.makeRefId)("Organizes"),
            resultMask
        }
    ];
    session.browse(nodesToBrowse, (err, browseResults) => {
        browseResults = browseResults || [];
        // istanbul ignore next
        if (err) {
            return callback(err);
        }
        if (doDebug) {
            debugLog("Components", t(browseResults[0].references));
            debugLog("Properties", t(browseResults[1].references));
            debugLog("Methods", t(browseResults[2].references));
        }
        async.series([
            (callback) => {
                async.mapSeries(browseResults[0].references, (reference, innerCallback) => add_component(proxyManager, obj, reference, innerCallback), (err) => callback(err));
            },
            (callback) => {
                async.mapSeries(browseResults[1].references, (reference, innerCallback) => add_property(proxyManager, obj, reference, innerCallback), (err) => callback(err));
            },
            // now enrich our object with nice callable async methods
            (callback) => {
                async.mapSeries(browseResults[2].references, (reference, innerCallback) => add_method(proxyManager, obj, reference, innerCallback), (err) => callback(err));
            },
            // now set typeDefinition
            (callback) => {
                add_typeDefinition(proxyManager, obj, browseResults[3].references, callback);
            },
            // FromState
            (callback) => {
                // fromState
                const reference = browseResults[4].references ? browseResults[4].references[0] : null;
                // fromState
                if (reference) {
                    return addFromState(proxyManager, obj, reference, callback);
                }
                callback();
            },
            // ToState
            (callback) => {
                const reference = browseResults[5].references ? browseResults[5].references[0] : null;
                // fromState
                if (reference) {
                    return addToState(proxyManager, obj, reference, callback);
                }
                callback();
            },
            // Organizes
            (callback) => {
                async.mapSeries(browseResults[6].references, (reference, callback) => addFolderElement(proxyManager, obj, reference, callback), (err) => callback(err));
            }
        ], (err) => callback(err));
    });
}
exports.readUAStructure = readUAStructure;
//# sourceMappingURL=object_explorer.js.map