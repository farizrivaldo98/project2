"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exploreCertificateRevocationList = exports.readNameForCrl = void 0;
const asn1_1 = require("./asn1");
const crypto_utils_1 = require("./crypto_utils");
function readNameForCrl(buffer, block) {
    return (0, asn1_1._readDirectoryName)(buffer, block);
}
exports.readNameForCrl = readNameForCrl;
function _readTbsCertList(buffer, blockInfo) {
    const blocks = (0, asn1_1._readStruct)(buffer, blockInfo);
    const hasOptionalVersion = blocks[0].tag === asn1_1.TagType.INTEGER;
    if (hasOptionalVersion) {
        const version = (0, asn1_1._readIntegerValue)(buffer, blocks[0]);
        const signature = (0, asn1_1._readAlgorithmIdentifier)(buffer, blocks[1]);
        const issuer = readNameForCrl(buffer, blocks[2]);
        const issuerFingerprint = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, crypto_utils_1.makeSHA1Thumbprint)((0, asn1_1._getBlock)(buffer, blocks[2])));
        const thisUpdate = (0, asn1_1._readTime)(buffer, blocks[3]);
        const nextUpdate = (0, asn1_1._readTime)(buffer, blocks[4]);
        const revokedCertificates = [];
        if (blocks[5] && blocks[5].tag < 0x80) {
            const list = (0, asn1_1._readStruct)(buffer, blocks[5]);
            for (const r of list) {
                // sometime blocks[5] doesn't exits .. in this case
                const rr = (0, asn1_1._readStruct)(buffer, r);
                const userCertificate = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._readLongIntegerValue)(buffer, rr[0]));
                const revocationDate = (0, asn1_1._readTime)(buffer, rr[1]);
                revokedCertificates.push({
                    revocationDate,
                    userCertificate,
                });
            }
        }
        const ext0 = (0, asn1_1._findBlockAtIndex)(blocks, 0);
        return { issuer, issuerFingerprint, thisUpdate, nextUpdate, signature, revokedCertificates };
    }
    else {
        const signature = (0, asn1_1._readAlgorithmIdentifier)(buffer, blocks[0]);
        const issuer = readNameForCrl(buffer, blocks[1]);
        const issuerFingerprint = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, crypto_utils_1.makeSHA1Thumbprint)((0, asn1_1._getBlock)(buffer, blocks[1])));
        const thisUpdate = (0, asn1_1._readTime)(buffer, blocks[2]);
        const nextUpdate = (0, asn1_1._readTime)(buffer, blocks[3]);
        const revokedCertificates = [];
        if (blocks[4] && blocks[4].tag < 0x80) {
            const list = (0, asn1_1._readStruct)(buffer, blocks[4]);
            for (const r of list) {
                // sometime blocks[5] doesn't exits .. in this case
                const rr = (0, asn1_1._readStruct)(buffer, r);
                const userCertificate = (0, asn1_1.formatBuffer2DigitHexWithColum)((0, asn1_1._readLongIntegerValue)(buffer, rr[0]));
                const revocationDate = (0, asn1_1._readTime)(buffer, rr[1]);
                revokedCertificates.push({
                    revocationDate,
                    userCertificate,
                });
            }
        }
        return { issuer, issuerFingerprint, thisUpdate, nextUpdate, signature, revokedCertificates };
    }
}
// see https://tools.ietf.org/html/rfc5280
function exploreCertificateRevocationList(crl) {
    const blockInfo = (0, asn1_1.readTag)(crl, 0);
    const blocks = (0, asn1_1._readStruct)(crl, blockInfo);
    const tbsCertList = _readTbsCertList(crl, blocks[0]);
    const signatureAlgorithm = (0, asn1_1._readAlgorithmIdentifier)(crl, blocks[1]);
    const signatureValue = (0, asn1_1._readSignatureValueBin)(crl, blocks[2]);
    return { tbsCertList, signatureAlgorithm, signatureValue };
}
exports.exploreCertificateRevocationList = exploreCertificateRevocationList;
//# sourceMappingURL=explore_certificate_revocation_list.js.map