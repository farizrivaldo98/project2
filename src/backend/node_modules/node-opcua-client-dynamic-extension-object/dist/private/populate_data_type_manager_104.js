"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateDataTypeManager104 = exports.readDataTypeDefinitionAndBuildType = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_schemas_1 = require("node-opcua-schemas");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_types_1 = require("node-opcua-types");
const convert_data_type_definition_to_structuretype_schema_1 = require("../convert_data_type_definition_to_structuretype_schema");
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
function readDataTypeDefinitionAndBuildType(session, dataTypeNodeId, name, dataTypeFactory, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (dataTypeFactory.getStructureInfoForDataType(dataTypeNodeId)) {
                return;
            }
            const [isAbstractDataValue, dataTypeDefinitionDataValue] = yield session.read([
                {
                    attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract,
                    nodeId: dataTypeNodeId
                },
                {
                    attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition,
                    nodeId: dataTypeNodeId
                }
            ]);
            /* istanbul ignore next */
            if (isAbstractDataValue.statusCode.isNotGood()) {
                throw new Error(" Cannot find dataType isAbstract ! with nodeId =" + dataTypeNodeId.toString());
            }
            const isAbstract = isAbstractDataValue.value.value;
            let dataTypeDefinition = dataTypeDefinitionDataValue.value.value;
            /* istanbul ignore next */
            if (dataTypeDefinitionDataValue.statusCode.isNotGood()) {
                // may be we are reading a 1.03 server
                if (!isAbstract) {
                    warningLog(" Cannot find dataType Definition ! with nodeId =" + dataTypeNodeId.toString());
                    return;
                }
                // it is OK to not have dataTypeDefinition for Abstract type!
                dataTypeDefinition = new node_opcua_types_1.StructureDefinition();
            }
            const schema = yield (0, convert_data_type_definition_to_structuretype_schema_1.convertDataTypeDefinitionToStructureTypeSchema)(session, dataTypeNodeId, name, dataTypeDefinition, dataTypeFactory, isAbstract, cache);
            if (isAbstract) {
                // cannot construct an abstract structure
                dataTypeFactory.registerAbstractStructure(dataTypeNodeId, name, schema);
            }
            else {
                const Constructor = (0, node_opcua_schemas_1.createDynamicObjectConstructor)(schema, dataTypeFactory);
            }
        }
        catch (err) {
            errorLog("Error", err);
        }
    });
}
exports.readDataTypeDefinitionAndBuildType = readDataTypeDefinitionAndBuildType;
class TaskMan {
    constructor() {
        this.taskList = [];
        this._runningTask = false;
        this._resolve = undefined;
    }
    flushTaskList() {
        return __awaiter(this, void 0, void 0, function* () {
            const firstTask = this.taskList.shift();
            this._runningTask = true;
            yield firstTask();
            this._runningTask = false;
            if (this.taskList.length > 0) {
                setImmediate(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.flushTaskList();
                }));
            }
            else {
                if (this._resolve) {
                    const tmpResolve = this._resolve;
                    this._resolve = undefined;
                    tmpResolve();
                }
            }
        });
    }
    /**
     *
     * a little async task queue that gets executed sequentially
     * outside the main loop
     */
    registerTask(taskFunc) {
        this.taskList.push(taskFunc);
        if (this.taskList.length === 1 && !this._runningTask) {
            this.flushTaskList();
        }
    }
    waitForCompletion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._resolve !== undefined) {
                throw new Error("already waiting");
            }
            yield new Promise((resolve) => {
                this._resolve = resolve;
            });
        });
    }
}
function applyOnReferenceRecursively(session, nodeId, browseDescriptionTemplate, action) {
    return __awaiter(this, void 0, void 0, function* () {
        const taskMananager = new TaskMan();
        let pendingNodesToBrowse = [];
        function processBrowseResults(nodesToBrowse, browseResults) {
            var _a;
            for (let i = 0; i < browseResults.length; i++) {
                const result = browseResults[i];
                const nodeToBrowse = nodesToBrowse[i];
                if (result.statusCode.equals(node_opcua_status_code_1.StatusCodes.BadNoContinuationPoints) ||
                    result.statusCode.equals(node_opcua_status_code_1.StatusCodes.BadContinuationPointInvalid)) {
                    // not enough continuation points .. we need to rebrowse
                    pendingNodesToBrowse.push(nodeToBrowse);
                    //                taskMananager.registerTask(flushBrowse);
                }
                else if (result.statusCode.isGood()) {
                    for (const r of result.references || []) {
                        // also explore sub types
                        browseSubDataTypeRecursively(r.nodeId);
                        taskMananager.registerTask(() => __awaiter(this, void 0, void 0, function* () { return yield action(r); }));
                    }
                }
                else {
                    errorLog("Unexpected status code", i, (_a = new node_opcua_types_1.BrowseDescription(nodesToBrowse[i] || {})) === null || _a === void 0 ? void 0 : _a.toString(), result.statusCode.toString());
                }
            }
        }
        function flushBrowse() {
            return __awaiter(this, void 0, void 0, function* () {
                if (pendingNodesToBrowse.length) {
                    const nodesToBrowse = pendingNodesToBrowse;
                    pendingNodesToBrowse = [];
                    taskMananager.registerTask(() => __awaiter(this, void 0, void 0, function* () {
                        try {
                            // YY console.log(" reading ", nodesToBrowse.length);
                            const browseResults = yield (0, node_opcua_pseudo_session_1.browseAll)(session, nodesToBrowse);
                            processBrowseResults(nodesToBrowse, browseResults);
                        }
                        catch (err) {
                            errorLog("err", err.message);
                            errorLog(nodesToBrowse.toString());
                        }
                    }));
                }
            });
        }
        function browseSubDataTypeRecursively(nodeId) {
            const nodeToBrowse = Object.assign(Object.assign({}, browseDescriptionTemplate), { nodeId });
            pendingNodesToBrowse.push(nodeToBrowse);
            taskMananager.registerTask(() => __awaiter(this, void 0, void 0, function* () { return flushBrowse(); }));
        }
        browseSubDataTypeRecursively(nodeId);
        yield taskMananager.waitForCompletion();
    });
}
function populateDataTypeManager104(session, dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = {};
        function withDataType(r) {
            return __awaiter(this, void 0, void 0, function* () {
                const dataTypeNodeId = r.nodeId;
                try {
                    if (dataTypeNodeId.namespace === 0) {
                        // already known I guess
                        return;
                    }
                    let dataTypeFactory = dataTypeManager.getDataTypeFactory(dataTypeNodeId.namespace);
                    if (!dataTypeFactory) {
                        dataTypeFactory = new node_opcua_factory_1.DataTypeFactory([]);
                        dataTypeManager.registerDataTypeFactory(dataTypeNodeId.namespace, dataTypeFactory);
                        //   throw new Error("cannot find dataType Manager for namespace of " + dataTypeNodeId.toString());
                    }
                    // if not found already
                    if (dataTypeFactory.getStructureInfoForDataType(dataTypeNodeId)) {
                        // already known !
                        return;
                    }
                    // extract it formally
                    debugLog(" DataType => ", r.browseName.toString(), dataTypeNodeId.toString());
                    yield readDataTypeDefinitionAndBuildType(session, dataTypeNodeId, r.browseName.name, dataTypeFactory, cache);
                }
                catch (err) {
                    errorLog("err=", err);
                }
            });
        }
        const nodeToBrowse = {
            nodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
            includeSubtypes: true,
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            nodeClassMask: 0xff,
            referenceTypeId: (0, node_opcua_nodeid_1.resolveNodeId)("HasSubtype"),
            resultMask: 0xff
        };
        yield applyOnReferenceRecursively(session, (0, node_opcua_nodeid_1.resolveNodeId)("Structure"), nodeToBrowse, withDataType);
    });
}
exports.populateDataTypeManager104 = populateDataTypeManager104;
//# sourceMappingURL=populate_data_type_manager_104.js.map