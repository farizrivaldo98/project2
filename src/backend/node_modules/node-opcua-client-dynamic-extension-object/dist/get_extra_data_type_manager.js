"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtraDataTypeManager = exports.invalidateExtraDataTypeManager = void 0;
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
//
const extra_data_type_manager_1 = require("./extra_data_type_manager");
const populate_data_type_manager_1 = require("./populate_data_type_manager");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const warningLog = errorLog;
function invalidateExtraDataTypeManager(session) {
    return __awaiter(this, void 0, void 0, function* () {
        const sessionPriv = session;
        sessionPriv.$$extraDataTypeManager = undefined;
        if (sessionPriv.$$extraDataTypeManagerToResolve) {
            warningLog("Warning: invalidateExtraDataTypeManager is called while getExtraDataTypeManager is in progress");
        }
    });
}
exports.invalidateExtraDataTypeManager = invalidateExtraDataTypeManager;
function extractDataTypeManager(session) {
    return __awaiter(this, void 0, void 0, function* () {
        const namespaceArray = yield (0, node_opcua_pseudo_session_1.readNamespaceArray)(session);
        // istanbul ignore next
        if (namespaceArray.length === 0) {
            errorLog("namespaceArray is not populated ! Your server must expose a list of namespace ");
        }
        // istanbul ignore next
        if (doDebug) {
            debugLog("Namespace Array = ", namespaceArray.join("\n                   "));
        }
        const dataTypeManager = new extra_data_type_manager_1.ExtraDataTypeManager();
        dataTypeManager.setNamespaceArray(namespaceArray);
        for (let namespaceIndex = 1; namespaceIndex < namespaceArray.length; namespaceIndex++) {
            const dataTypeFactory1 = new node_opcua_factory_1.DataTypeFactory([(0, node_opcua_factory_1.getStandardDataTypeFactory)()]);
            dataTypeManager.registerDataTypeFactory(namespaceIndex, dataTypeFactory1);
        }
        yield (0, populate_data_type_manager_1.populateDataTypeManager)(session, dataTypeManager);
        // istanbul ignore next
        if (dataTypeManager.namespaceArray.length === 0) {
            throw new Error("namespaceArray is not populated ! Your server must expose a list of namespace ");
        }
        return dataTypeManager;
    });
}
function getExtraDataTypeManager(session) {
    return __awaiter(this, void 0, void 0, function* () {
        const sessionPriv = session;
        if (sessionPriv.$$extraDataTypeManager) {
            return sessionPriv.$$extraDataTypeManager;
        }
        if (sessionPriv.$$extraDataTypeManagerToResolve) {
            doDebug && debugLog("getExtraDataTypeManager is re-entering !");
            return yield new Promise((resolve, reject) => {
                var _a;
                (_a = sessionPriv.$$extraDataTypeManagerToResolve) === null || _a === void 0 ? void 0 : _a.push([resolve, reject]);
            });
        }
        sessionPriv.$$extraDataTypeManagerToResolve = [];
        return yield new Promise((_resolve, _reject) => {
            sessionPriv.$$extraDataTypeManagerToResolve.push([_resolve, _reject]);
            (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const dataTypeManager = yield extractDataTypeManager(session);
                    const tmp = sessionPriv.$$extraDataTypeManagerToResolve;
                    sessionPriv.$$extraDataTypeManagerToResolve = undefined;
                    for (const [resolve] of tmp) {
                        resolve(dataTypeManager);
                    }
                    sessionPriv.$$extraDataTypeManager = dataTypeManager;
                }
                catch (err) {
                    const tmp = sessionPriv.$$extraDataTypeManagerToResolve;
                    sessionPriv.$$extraDataTypeManagerToResolve = undefined;
                    for (const [_resolve, reject] of tmp) {
                        reject(err);
                    }
                }
            }))();
        });
    });
}
exports.getExtraDataTypeManager = getExtraDataTypeManager;
//# sourceMappingURL=get_extra_data_type_manager.js.map