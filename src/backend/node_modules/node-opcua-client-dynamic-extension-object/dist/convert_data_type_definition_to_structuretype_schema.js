"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDataTypeDefinitionToStructureTypeSchema = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
//import { DataTypeIds } from "node-opcua-constant";
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_nodeid_2 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_extension_object_1 = require("node-opcua-extension-object");
//
const node_opcua_variant_1 = require("node-opcua-variant");
const find_encodings_1 = require("./private/find_encodings");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
function findSuperType(session, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === 24) {
            // BaseDataType !
            return (0, node_opcua_nodeid_2.coerceNodeId)(0);
        }
        const nodeToBrowse3 = {
            browseDirection: node_opcua_data_model_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
            nodeId: dataTypeNodeId,
            referenceTypeId: (0, node_opcua_nodeid_2.resolveNodeId)("HasSubtype"),
            resultMask: (0, node_opcua_data_model_1.makeResultMask)("NodeId | ReferenceType | BrowseName | NodeClass")
        };
        const result3 = yield (0, node_opcua_pseudo_session_1.browseAll)(session, nodeToBrowse3);
        /* istanbul ignore next */
        if (result3.statusCode.isNotGood()) {
            throw new Error("Cannot find superType for " + dataTypeNodeId.toString());
        }
        result3.references = result3.references || [];
        /* istanbul ignore next */
        if (result3.references.length !== 1) {
            console.log(result3.toString());
            throw new Error("Invalid dataType with more than one (or 0) superType " + dataTypeNodeId.toString() + " l=" + result3.references.length);
        }
        return result3.references[0].nodeId;
    });
}
function findDataTypeCategory(session, cache, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const subTypeNodeId = yield findSuperType(session, dataTypeNodeId);
        debugLog("subTypeNodeId  of ", dataTypeNodeId.toString(), " is ", subTypeNodeId.toString());
        const key = subTypeNodeId.toString();
        if (cache[key]) {
            return cache[key].category;
        }
        let category;
        const n = subTypeNodeId;
        if (n.identifierType === node_opcua_nodeid_1.NodeIdType.NUMERIC && n.namespace === 0 && n.value <= 29) {
            // well known node ID !
            switch (n.value) {
                case 22 /* Structure */:
                    category = node_opcua_factory_1.FieldCategory.complex;
                    break;
                case 29 /* Enumeration */:
                    category = node_opcua_factory_1.FieldCategory.enumeration;
                    break;
                default:
                    category = node_opcua_factory_1.FieldCategory.basic;
                    break;
            }
            return category;
        }
        // must drill down ...
        return yield findDataTypeCategory(session, cache, subTypeNodeId);
    });
}
function findDataTypeBasicType(session, cache, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const subTypeNodeId = yield findSuperType(session, dataTypeNodeId);
        debugLog("subTypeNodeId  of ", dataTypeNodeId.toString(), " is ", subTypeNodeId.toString());
        const key = subTypeNodeId.toString();
        if (cache[key]) {
            return cache[key].schema;
        }
        const n = subTypeNodeId;
        if (n.identifierType === node_opcua_nodeid_1.NodeIdType.NUMERIC && n.namespace === 0 && n.value < 29) {
            switch (n.value) {
                case 22: /* Structure */
                case 29 /* Enumeration */:
                    throw new Error("Not expecting Structure or Enumeration");
                default:
                    break;
            }
            const nameDataValue = yield session.read({
                attributeId: node_opcua_data_model_1.AttributeIds.BrowseName,
                nodeId: subTypeNodeId
            });
            const name = nameDataValue.value.value.name;
            return (0, node_opcua_factory_1.getBuiltInType)(name);
        }
        // must drill down ...
        return yield findDataTypeBasicType(session, cache, subTypeNodeId);
    });
}
function readBrowseName(session, nodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataValue = yield session.read({ nodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName });
        if (dataValue.statusCode.isNotGood()) {
            const message = "cannot extract BrowseName of nodeId = " + nodeId.toString() + " statusCode = " + dataValue.statusCode.toString();
            debugLog(message);
            throw new Error(message);
        }
        return dataValue.value.value.name;
    });
}
function resolve2(session, dataTypeNodeId, dataTypeFactory, fieldTypeName, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        const category = yield findDataTypeCategory(session, cache, dataTypeNodeId);
        debugLog(" type " + fieldTypeName + " has not been seen yet, let resolve it => (category = ", category, " )");
        let schema = undefined;
        switch (category) {
            case node_opcua_factory_1.FieldCategory.basic:
                schema = yield findDataTypeBasicType(session, cache, dataTypeNodeId);
                /* istanbul ignore next */
                if (!schema) {
                    errorLog("Cannot find basic type " + fieldTypeName);
                }
                break;
            default:
            case node_opcua_factory_1.FieldCategory.complex:
                {
                    const dataTypeDefinitionDataValue = yield session.read({
                        attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition,
                        nodeId: dataTypeNodeId
                    });
                    /* istanbul ignore next */
                    if (dataTypeDefinitionDataValue.statusCode.isNotGood()) {
                        throw new Error(" Cannot find dataType Definition ! with nodeId =" + dataTypeNodeId.toString());
                    }
                    const definition = dataTypeDefinitionDataValue.value.value;
                    const convertIn64ToInteger = (a) => a[1];
                    const convert = (fields) => {
                        const retVal = {};
                        fields && fields.forEach((field) => (retVal[field.name || ""] = convertIn64ToInteger(field.value)));
                        return retVal;
                    };
                    if (category === node_opcua_factory_1.FieldCategory.enumeration) {
                        if (definition instanceof node_opcua_types_1.EnumDefinition) {
                            const e = new node_opcua_factory_1.EnumerationDefinitionSchema(dataTypeNodeId, {
                                enumValues: convert(definition.fields),
                                name: fieldTypeName
                            });
                            dataTypeFactory.registerEnumeration(e);
                            schema = e;
                        }
                    }
                    else {
                        const isAbstract = false;
                        schema = yield convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, fieldTypeName, definition, dataTypeFactory, isAbstract, cache);
                    }
                    // xx const schema1 = dataTypeFactory.getStructuredTypeSchema(fieldTypeName);
                }
                break;
        }
        return { schema, category };
    });
}
const isExtensionObject = (session, dataTypeNodeId) => __awaiter(void 0, void 0, void 0, function* () {
    if (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === node_opcua_variant_1.DataType.ExtensionObject) {
        return true;
    }
    const baseDataType = yield findSuperType(session, dataTypeNodeId);
    const bn = baseDataType;
    if (bn.identifierType === node_opcua_nodeid_1.NodeIdType.NUMERIC) {
        if (bn.namespace === 0 && bn.value === node_opcua_variant_1.DataType.ExtensionObject) {
            return true;
        }
        if (bn.namespace === 0 && bn.value < node_opcua_variant_1.DataType.ExtensionObject) {
            return false;
        }
    }
    return yield isExtensionObject(session, baseDataType);
});
// eslint-disable-next-line max-statements
function resolveFieldType(session, dataTypeNodeId, dataTypeFactory, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        if (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === 22) {
            // ERN   return null;
            const category = node_opcua_factory_1.FieldCategory.complex;
            const fieldTypeName = "Structure";
            const schema = node_opcua_extension_object_1.ExtensionObject.schema;
            return {
                category,
                fieldTypeName,
                schema,
                allowSubType: true,
                dataType: (0, node_opcua_nodeid_2.coerceNodeId)(node_opcua_variant_1.DataType.ExtensionObject)
            };
        }
        const key = dataTypeNodeId.toString();
        const v = cache[key];
        if (v) {
            return v;
        }
        if (dataTypeNodeId.value === 0) {
            const v3 = {
                category: node_opcua_factory_1.FieldCategory.basic,
                fieldTypeName: "Variant",
                schema: dataTypeFactory.getBuiltInType("Variant")
            };
            cache[key] = v3;
            return v3;
        }
        const isAbstract = (yield session.read({ nodeId: dataTypeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract })).value.value;
        const fieldTypeName = yield readBrowseName(session, dataTypeNodeId);
        if (isAbstract) {
            const _isExtensionObject = yield isExtensionObject(session, dataTypeNodeId);
            debugLog(" dataType " + dataTypeNodeId.toString() + " " + fieldTypeName + " is abstract => extObj ?= " + _isExtensionObject);
            if (_isExtensionObject) {
                // we could have complex => Structure
                const v3 = {
                    category: node_opcua_factory_1.FieldCategory.complex,
                    fieldTypeName: fieldTypeName,
                    schema: node_opcua_extension_object_1.ExtensionObject.schema,
                    allowSubType: true,
                    dataType: dataTypeNodeId
                };
                cache[key] = v3;
                return v3;
            }
            else {
                // we could have basic => Variant
                const v3 = {
                    category: node_opcua_factory_1.FieldCategory.basic,
                    fieldTypeName: fieldTypeName,
                    schema: dataTypeFactory.getBuiltInType("Variant"),
                    allowSubType: true,
                    dataType: dataTypeNodeId
                };
                cache[key] = v3;
                return v3;
            }
        }
        let schema;
        let category = node_opcua_factory_1.FieldCategory.enumeration;
        if (dataTypeFactory.hasStructureByTypeName(fieldTypeName)) {
            schema = dataTypeFactory.getStructuredTypeSchema(fieldTypeName);
            category = node_opcua_factory_1.FieldCategory.complex;
        }
        else if (dataTypeFactory.hasBuiltInType(fieldTypeName)) {
            category = node_opcua_factory_1.FieldCategory.basic;
            schema = dataTypeFactory.getBuiltInType(fieldTypeName);
        }
        else if (dataTypeFactory.hasEnumeration(fieldTypeName)) {
            category = node_opcua_factory_1.FieldCategory.enumeration;
            schema = dataTypeFactory.getEnumeration(fieldTypeName);
        }
        else {
            debugLog(" type " + fieldTypeName + " has not been seen yet, let resolve it");
            const res = yield resolve2(session, dataTypeNodeId, dataTypeFactory, fieldTypeName, cache);
            schema = res.schema;
            category = res.category;
        }
        /* istanbul ignore next */
        if (!schema) {
            throw new Error("expecting a schema here fieldTypeName=" + fieldTypeName + " " + dataTypeNodeId.toString() + " category = " + category);
        }
        const v2 = {
            category,
            fieldTypeName,
            schema
        };
        cache[key] = v2;
        return v2;
    });
}
function _setupEncodings(session, dataTypeNodeId, schema) {
    return __awaiter(this, void 0, void 0, function* () {
        // read abstract flag
        const isAbstractDV = yield session.read({ nodeId: dataTypeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract });
        schema.dataTypeNodeId = dataTypeNodeId;
        if (isAbstractDV.statusCode.isGood() && isAbstractDV.value.value === false) {
            const encodings = yield (0, find_encodings_1._findEncodings)(session, dataTypeNodeId);
            schema.encodingDefaultBinary = (0, node_opcua_nodeid_2.makeExpandedNodeId)(encodings.binaryEncodingNodeId);
            schema.encodingDefaultXml = (0, node_opcua_nodeid_2.makeExpandedNodeId)(encodings.xmlEncodingNodeId);
            schema.encodingDefaultJson = (0, node_opcua_nodeid_2.makeExpandedNodeId)(encodings.jsonEncodingNodeId);
        }
        return schema;
    });
}
// eslint-disable-next-line max-statements
function convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, name, definition, dataTypeFactory, isAbstract, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        if (definition instanceof node_opcua_types_1.StructureDefinition) {
            let fieldCountToIgnore = 0;
            const structureInfo = dataTypeFactory.getStructureInfoForDataType(definition.baseDataType);
            const baseSchema = structureInfo === null || structureInfo === void 0 ? void 0 : structureInfo.schema;
            if (baseSchema) {
                const possibleFields = (0, node_opcua_factory_1.extractAllPossibleFields)(baseSchema);
                fieldCountToIgnore += possibleFields.length;
            }
            // while (base && !(base.dataTypeNodeId.value === DataType.ExtensionObject && base.dataTypeNodeId.namespace === 0)) {
            //     fieldCountToIgnore += base..length;
            //     base = base.getBaseSchema();
            // }
            const fields = [];
            const isUnion = definition.structureType === node_opcua_types_1.StructureType.Union;
            switch (definition.structureType) {
                case node_opcua_types_1.StructureType.Union:
                    // xx console.log("Union Found : ", name);
                    fields.push({
                        fieldType: "UInt32",
                        name: "SwitchField"
                    });
                    break;
                case node_opcua_types_1.StructureType.Structure:
                case node_opcua_types_1.StructureType.StructureWithOptionalFields:
                    break;
            }
            let switchValue = 1;
            let switchBit = 0;
            const bitFields = isUnion ? undefined : [];
            const postActions = [];
            if (definition.fields) {
                for (let i = fieldCountToIgnore; i < definition.fields.length; i++) {
                    const fieldD = definition.fields[i];
                    // we need to skip fields that have already been handled in base class
                    let field;
                    ({ field, switchBit, switchValue } = createField(fieldD, switchBit, bitFields, isUnion, switchValue));
                    if (fieldD.dataType.value === dataTypeNodeId.value && fieldD.dataType.namespace === dataTypeNodeId.namespace) {
                        // this is a structure with a field of the same type
                        // push an empty placeholder that we will fill later
                        const fieldTypeName = yield readBrowseName(session, dataTypeNodeId);
                        (field.fieldType = fieldTypeName), (field.category = node_opcua_factory_1.FieldCategory.complex);
                        fields.push(field);
                        const capturedField = field;
                        postActions.push((schema) => {
                            capturedField.schema = schema;
                        });
                        continue;
                    }
                    const rt = (yield resolveFieldType(session, fieldD.dataType, dataTypeFactory, cache));
                    if (!rt) {
                        errorLog("convertDataTypeDefinitionToStructureTypeSchema cannot handle field", fieldD.name, "in", name, "because " + fieldD.dataType.toString() + " cannot be resolved");
                        continue;
                    }
                    const { schema, category, fieldTypeName, dataType, allowSubType } = rt;
                    field.fieldType = fieldTypeName;
                    field.category = category;
                    field.schema = schema;
                    field.dataType = dataType || fieldD.dataType;
                    field.allowSubType = allowSubType || false;
                    field.basicDataType = yield (0, node_opcua_pseudo_session_1.findBasicDataType)(session, field.dataType);
                    fields.push(field);
                }
            }
            /// some server may provide definition.baseDataType to be i=22 (ExtensionObject)
            /// instead of 12756 Union;
            if (isUnion && (0, node_opcua_nodeid_1.sameNodeId)(definition.baseDataType, (0, node_opcua_nodeid_2.coerceNodeId)("i=22"))) {
                definition.baseDataType = (0, node_opcua_nodeid_2.resolveNodeId)("i=1276"); // aka DataTypeIds.Union
            }
            const a = yield resolveFieldType(session, definition.baseDataType, dataTypeFactory, cache);
            const baseType = a ? a.fieldTypeName : isUnion ? "Union" : "ExtensionObject";
            const os = new node_opcua_factory_1.StructuredTypeSchema({
                baseType,
                bitFields,
                fields,
                name,
                dataTypeFactory
            });
            const structuredTypeSchema = yield _setupEncodings(session, dataTypeNodeId, os);
            postActions.forEach((action) => action(structuredTypeSchema));
            return structuredTypeSchema;
        }
        throw new Error("Not Implemented");
        function createField(fieldD, switchBit, bitFields, isUnion, switchValue) {
            const field = {
                fieldType: "",
                name: fieldD.name,
                schema: undefined
            };
            if (fieldD.isOptional) {
                field.switchBit = switchBit++;
                bitFields === null || bitFields === void 0 ? void 0 : bitFields.push({ name: fieldD.name + "Specified", length: 1 });
            }
            if (isUnion) {
                field.switchValue = switchValue;
                switchValue += 1;
            }
            // (fieldD.valueRank === -1 || fieldD.valueRank === 1 || fieldD.valueRank === 0);
            if (fieldD.valueRank >= 1) {
                field.valueRank = fieldD.valueRank;
                field.isArray = true;
            }
            else {
                field.isArray = false;
            }
            return { field, switchBit, switchValue };
        }
    });
}
exports.convertDataTypeDefinitionToStructureTypeSchema = convertDataTypeDefinitionToStructureTypeSchema;
//# sourceMappingURL=convert_data_type_definition_to_structuretype_schema.js.map