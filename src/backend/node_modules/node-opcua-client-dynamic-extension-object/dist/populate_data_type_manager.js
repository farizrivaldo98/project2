"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateDataTypeManager = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_constants_1 = require("node-opcua-constants");
const node_opcua_variant_1 = require("node-opcua-variant");
const populate_data_type_manager_103_1 = require("./private/populate_data_type_manager_103");
const populate_data_type_manager_104_1 = require("./private/populate_data_type_manager_104");
function serverImplementsDataTypeDefinition(session) {
    return __awaiter(this, void 0, void 0, function* () {
        // check if server provides DataTypeDefinition => in this case this is the prefered route,
        // as we go along, more and more servers will implement this.
        const browseResult = yield (0, node_opcua_pseudo_session_1.browseAll)(session, {
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
            nodeId: (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_variant_1.DataType.ExtensionObject),
            referenceTypeId: "HasSubtype",
            resultMask: 63
        });
        const browseResult2 = yield (0, node_opcua_pseudo_session_1.browseAll)(session, {
            browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
            nodeId: (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.DataTypeIds.Union),
            referenceTypeId: "HasSubtype",
            resultMask: 63
        });
        let references = [];
        if (browseResult && browseResult.references)
            references = references.concat(browseResult.references);
        if (browseResult2 && browseResult2.references)
            references = references.concat(browseResult2.references);
        if (references.length === 0)
            return false;
        // DataType Structure from namespace 0 are not interesting and will not provide DataTypeDefinition attribute anyway
        // on some servers.
        references = references.filter((a, index) => a.nodeId.namespace !== 0);
        if (references.length === 0)
            return false;
        let nodesToRead = references.map((r) => ({
            nodeId: r.nodeId,
            attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition
        }));
        const nodesToRead2 = nodesToRead.map((r) => ({ nodeId: r.nodeId, attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract }));
        const abstractFlags = (yield session.read(nodesToRead2)).map((d) => d.value.value);
        // also remove the abstract dataStructure => they don't provide valid DataTypeDefinition
        nodesToRead = nodesToRead.filter((_nodesToRead, index) => !abstractFlags[index]);
        if (nodesToRead.length === 0)
            return false;
        const dataValues = yield session.read(nodesToRead);
        // for (let i = 0; i < dataValues.length; i++) {
        //     console.log(i, " | ", nodesToRead[i].nodeId.toString().padEnd(40), references[i].browseName.toString().padEnd(50), dataValues[i].statusCode.toString());
        // }
        const countOK = dataValues.reduce((prev, a) => prev + (a.statusCode.isGood() ? 1 : 0), 0);
        if (countOK === dataValues.length) {
            return true;
            // await populateDataTypeManager104(session, dataTypeManager);
            // return;
        }
        return false;
    });
}
function populateDataTypeManager(session, dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        const force104 = yield serverImplementsDataTypeDefinition(session);
        if (force104) {
            // console.log("xxxxxxx! using 1.04");
            yield (0, populate_data_type_manager_104_1.populateDataTypeManager104)(session, dataTypeManager);
            return;
        }
        // old way for 1.03 and early 1.04 prototype
        yield (0, populate_data_type_manager_103_1.populateDataTypeManager103)(session, dataTypeManager);
        yield (0, populate_data_type_manager_104_1.populateDataTypeManager104)(session, dataTypeManager);
    });
}
exports.populateDataTypeManager = populateDataTypeManager;
//# sourceMappingURL=populate_data_type_manager.js.map