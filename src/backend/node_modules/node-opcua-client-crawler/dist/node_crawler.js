"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeCrawler = void 0;
const chalk = require("chalk");
const async = require("async");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_crawler_base_1 = require("./node_crawler_base");
const cache_node_1 = require("./cache_node");
const private_1 = require("./private");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
class NodeCrawler extends node_crawler_base_1.NodeCrawlerBase {
    constructor(session) {
        super(session);
        this._objMap = {};
    }
    dispose() {
        Object.values(this._objMap).map((obj) => {
            Object.keys(obj).map((k) => (obj[k] = undefined));
        });
        this._objMap = null;
        super.dispose();
    }
    read(nodeId, callback) {
        /* istanbul ignore next */
        if (!callback) {
            throw new Error("Invalid Error");
        }
        try {
            nodeId = (0, node_opcua_nodeid_1.resolveNodeId)(nodeId);
        } /* istanbul ignore next */
        catch (err) {
            callback(err);
            return;
        }
        const key = nodeId.toString();
        // check if object has already been crawled
        if (Object.prototype.hasOwnProperty.call(this._objMap, key)) {
            const object = this._objMap[key];
            return callback(null, object);
        }
        const userData = {
            onBrowse: node_crawler_base_1.NodeCrawlerBase.follow
        };
        this.crawl(nodeId, userData, (err) => {
            /* istanbul ignore next */
            if (err) {
                return callback(err);
            }
            /* istanbul ignore else */
            if (Object.prototype.hasOwnProperty.call(this._objectCache, key)) {
                const cacheNode = this._objectCache[key];
                (0, node_opcua_assert_1.assert)(cacheNode.browseName.name !== "pending");
                this.simplify_object(this._objMap, cacheNode, callback);
            }
            else {
                callback(new Error("Cannot find nodeId" + key));
            }
        });
    }
    simplify_object(objMap, object, finalCallback) {
        (0, node_opcua_assert_1.assert)(typeof finalCallback === "function");
        const queue = async.queue((task, innerCallback) => {
            setImmediate(() => {
                (0, node_opcua_assert_1.assert)(typeof task.func === "function");
                task.func(task, innerCallback);
            });
        }, 1);
        // tslint:disable:no-empty
        this._add_for_reconstruction(queue, objMap, object, () => {
            /* */
        });
        const key1 = object.nodeId.toString();
        queue.drain(() => {
            const object1 = this._objMap[key1];
            (0, private_1.removeCycle)(object1, finalCallback);
        });
    }
    _add_for_reconstruction(queue, objMap, object, extraFunc) {
        if (!object || !object.nodeId) {
            return;
        }
        (0, node_opcua_assert_1.assert)(typeof extraFunc === "function");
        (0, node_opcua_assert_1.assert)(typeof object.nodeId.toString() === "string");
        const task = {
            data: object,
            func: (data, callback) => {
                this._reconstruct_manageable_object(queue, objMap, object, (err, obj) => {
                    extraFunc(err, obj);
                    callback(err || undefined);
                });
            }
        };
        queue.push(task);
    }
    _reconstruct_manageable_object(queue, objMap, object, callback) {
        (0, node_opcua_assert_1.assert)(typeof callback === "function");
        (0, node_opcua_assert_1.assert)(object);
        (0, node_opcua_assert_1.assert)(object.nodeId);
        const key2 = object.nodeId.toString();
        if (Object.prototype.hasOwnProperty.call(objMap, key2)) {
            return callback(null, objMap[key2]);
        }
        /* reconstruct a more manageable object
         * var obj = {
         *    browseName: "Objects",
         *    organizes : [
         *       {
         *            browseName: "Server",
         *            hasComponent: [
         *            ]
         *            hasProperty: [
         *            ]
         *       }
         *    ]
         * }
         */
        const obj = {
            browseName: object.browseName.name,
            nodeId: object.nodeId.toString()
        };
        // Append nodeClass
        if (object.nodeClass) {
            obj.nodeClass = object.nodeClass.toString();
        }
        if (object instanceof cache_node_1.CacheNodeVariable || object instanceof cache_node_1.CacheNodeVariableType) {
            if (object.dataType) {
                obj.dataType = object.dataType.toJSON();
                // xx obj.dataTypeName = object.dataTypeName;
            }
            if (object.dataValue) {
                obj.dataValue = object.dataValue.toJSON();
            }
        }
        objMap[key2] = obj;
        const referenceMap = obj;
        object.references = object.references || [];
        object.references.map((ref) => {
            var _a;
            (0, node_opcua_assert_1.assert)(ref);
            const refIndex = ref.referenceTypeId.toString();
            const referenceType = this._objectCache[refIndex];
            /* istanbul ignore else */
            if (!referenceType) {
                warningLog(chalk.red("Unknown reference type " + refIndex));
                // debugLog(util.inspect(object, { colors: true, depth: 10 }));
            }
            const reference = this._objectCache[ref.nodeId.toString()];
            /* istanbul ignore else */
            if (!reference) {
                warningLog(ref.nodeId.toString(), "bn=", ref.browseName.toString(), "class =", node_opcua_data_model_1.NodeClass[ref.nodeClass], ref.typeDefinition.toString());
                warningLog("Crawler: Cannot find reference", ref.nodeId.toString(), "in cache");
                warningLog("contact Sterfive's professional support for help to resolve");
            }
            if (reference) {
                // Extract nodeClass so it can be appended
                reference.nodeClass = ref.$nodeClass;
            }
            if (referenceType) {
                const refName = (0, node_opcua_utils_1.lowerFirstLetter)(((_a = referenceType === null || referenceType === void 0 ? void 0 : referenceType.browseName) === null || _a === void 0 ? void 0 : _a.name) || "");
                if (refName === "hasTypeDefinition") {
                    obj.typeDefinition = reference === null || reference === void 0 ? void 0 : reference.browseName.name;
                }
                else {
                    if (!referenceMap[refName]) {
                        referenceMap[refName] = [];
                    }
                    this._add_for_reconstruction(queue, objMap, reference, (err, mObject) => {
                        if (!err) {
                            referenceMap[refName].push(mObject);
                        }
                    });
                }
            }
        });
        callback(null, obj);
    }
}
exports.NodeCrawler = NodeCrawler;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
NodeCrawler.prototype.read = thenify.withCallback(NodeCrawler.prototype.read);
//# sourceMappingURL=node_crawler.js.map