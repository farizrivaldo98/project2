"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerTCP_transport = void 0;
const util_1 = require("util");
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
// opcua requires
const debug = require("node-opcua-debug");
const node_opcua_binary_stream_1 = require("node-opcua-binary-stream");
const node_opcua_chunkmanager_1 = require("node-opcua-chunkmanager");
const node_opcua_status_code_1 = require("node-opcua-status-code");
// this package requires
const AcknowledgeMessage_1 = require("./AcknowledgeMessage");
const HelloMessage_1 = require("./HelloMessage");
const tcp_transport_1 = require("./tcp_transport");
const tools_1 = require("./tools");
const utils_1 = require("./utils");
const hexDump = debug.hexDump;
const debugLog = debug.make_debugLog("TRANSPORT");
const errorLog = debug.make_errorLog("TRANSPORT");
const warningLog = debug.make_warningLog("TRANSPORT");
const doDebug = debug.checkDebugFlag("TRANSPORT");
function clamp_value(value, minVal, maxVal) {
    (0, node_opcua_assert_1.assert)(minVal < maxVal);
    if (value === 0) {
        return maxVal;
    }
    if (value < minVal) {
        return minVal;
    }
    /* istanbul ignore next*/
    if (value >= maxVal) {
        return maxVal;
    }
    return value;
}
const minimumBufferSize = 8192;
class ServerTCP_transport extends tcp_transport_1.TCP_transport {
    constructor() {
        super();
        this._aborted = 0;
        this._helloReceived = false;
        // before HEL/ACK
        this.maxChunkCount = 1;
        this.maxMessageSize = 4 * 1024;
        this.receiveBufferSize = 4 * 1024;
    }
    toString() {
        let str = super.toString();
        str += "helloReceived...... = " + this._helloReceived + "\n";
        str += "aborted............ = " + this._aborted + "\n";
        return str;
    }
    _write_chunk(messageChunk) {
        // istanbul ignore next
        if (this.sendBufferSize > 0 && messageChunk.length > this.sendBufferSize) {
            errorLog("write chunk exceed sendBufferSize messageChunk length = ", messageChunk.length, "sendBufferSize = ", this.sendBufferSize);
        }
        super._write_chunk(messageChunk);
    }
    /**
     * Initialize the server transport.
     *
     *
     *  The ServerTCP_transport initialization process starts by waiting for the client to send a "HEL" message.
     *
     *  The  ServerTCP_transport replies with a "ACK" message and then start waiting for further messages of any size.
     *
     *  The callback function received an error:
     *   - if no message from the client is received within the ```self.timeout``` period,
     *   - or, if the connection has dropped within the same interval.
     *   - if the protocol version specified within the HEL message is invalid or is greater
     *     than ```self.protocolVersion```
     *
     *
     */
    init(socket, callback) {
        (0, node_opcua_assert_1.assert)(socket, "missing called!");
        // istanbul ignore next
        debugLog && debugLog(chalk.cyan("init socket"));
        (0, node_opcua_assert_1.assert)(!this._socket, "init already called!");
        (0, node_opcua_assert_1.assert)(typeof callback === "function", "expecting a valid callback ");
        this._install_socket(socket);
        this._install_HEL_message_receiver(callback);
    }
    _abortWithError(statusCode, extraErrorDescription, callback) {
        var _a;
        // When a fatal error occurs, the Server shall send an Error Message to the Client and
        // closes the TransportConnection gracefully.
        doDebug && debugLog(this.name, chalk.cyan("_abortWithError", statusCode.toString(), extraErrorDescription));
        /* istanbul ignore next */
        if (this._aborted) {
            errorLog("Internal Er!ror: _abortWithError already called! Should not happen here");
            // already called
            return callback(new Error(statusCode.name));
        }
        this._aborted = 1;
        (_a = this._socket) === null || _a === void 0 ? void 0 : _a.setTimeout(0);
        const err = new Error(extraErrorDescription + " StatusCode = " + statusCode.name);
        this._theCloseError = err;
        setTimeout(() => {
            // send the error message and close the connection
            this.sendErrorMessage(statusCode, statusCode.description);
            this.prematureTerminate(err, statusCode);
            this._emitClose(err);
            callback(err);
        }, ServerTCP_transport.throttleTime);
    }
    _send_ACK_response(helloMessage) {
        (0, node_opcua_assert_1.assert)(helloMessage.receiveBufferSize >= minimumBufferSize);
        (0, node_opcua_assert_1.assert)(helloMessage.sendBufferSize >= minimumBufferSize);
        const minBufferSize = 8192;
        const maxBufferSize = 8 * 64 * 1024;
        const minMaxMessageSize = 128 * 1024;
        const defaultMaxMessageSize = 16 * 1024 * 1024;
        const maxMaxMessageSize = 128 * 1024 * 1024;
        const minMaxChunkCount = 1;
        const defaultMaxChunkCount = defaultMaxMessageSize / maxBufferSize;
        const maxMaxChunkCount = 9000;
        const defaultReceiveBufferSize = 64 * 1024;
        const defaultSendBufferSize = 64 * 1024;
        const receiveBufferSize = clamp_value(helloMessage.receiveBufferSize || defaultReceiveBufferSize, minBufferSize, maxBufferSize);
        const sendBufferSize = clamp_value(helloMessage.sendBufferSize || defaultSendBufferSize, minBufferSize, maxBufferSize);
        const maxMessageSize = clamp_value(helloMessage.maxMessageSize || defaultMaxMessageSize, minMaxMessageSize, maxMaxMessageSize);
        if (!helloMessage.maxChunkCount && sendBufferSize) {
            helloMessage.maxChunkCount = Math.ceil(helloMessage.maxMessageSize / Math.min(sendBufferSize, receiveBufferSize));
        }
        const maxChunkCount = clamp_value(helloMessage.maxChunkCount || defaultMaxChunkCount, minMaxChunkCount, maxMaxChunkCount);
        this.setLimits({
            receiveBufferSize,
            sendBufferSize,
            maxMessageSize,
            maxChunkCount
        });
        // istanbul ignore next
        if (utils_1.doTraceHelloAck) {
            warningLog(`received Hello \n${helloMessage.toString()}`);
            warningLog("Client accepts only message of size => ", this.maxMessageSize);
        }
        // istanbul ignore next
        doDebug && debugLog("Client accepts only message of size => ", this.maxMessageSize);
        const acknowledgeMessage = new AcknowledgeMessage_1.AcknowledgeMessage({
            maxChunkCount: this.maxChunkCount,
            maxMessageSize: this.maxMessageSize,
            protocolVersion: this.protocolVersion,
            receiveBufferSize: this.receiveBufferSize,
            sendBufferSize: this.sendBufferSize
        });
        // istanbul ignore next
        utils_1.doTraceHelloAck && warningLog(`sending Ack \n${acknowledgeMessage.toString()}`);
        const messageChunk = (0, tools_1.packTcpMessage)("ACK", acknowledgeMessage);
        /* istanbul ignore next*/
        if (doDebug) {
            (0, node_opcua_chunkmanager_1.verify_message_chunk)(messageChunk);
            debugLog("server send: " + chalk.yellow("ACK"));
            debugLog("server send: " + hexDump(messageChunk));
            debugLog("acknowledgeMessage=", acknowledgeMessage);
        }
        // send the ACK reply
        this.write(messageChunk);
    }
    _install_HEL_message_receiver(callback) {
        // istanbul ignore next
        doDebug && debugLog(chalk.cyan("_install_HEL_message_receiver "));
        this._install_one_time_message_receiver((err, data) => {
            if (err) {
                callback(err);
            }
            else {
                // handle the HEL message
                this._on_HEL_message(data, callback);
            }
        });
    }
    _on_HEL_message(data, callback) {
        // istanbul ignore next
        doDebug && debugLog(chalk.cyan("_on_HEL_message"));
        (0, node_opcua_assert_1.assert)(!this._helloReceived);
        const stream = new node_opcua_binary_stream_1.BinaryStream(data);
        const msgType = data.subarray(0, 3).toString("utf-8");
        /* istanbul ignore next*/
        if (doDebug) {
            debugLog("SERVER received " + chalk.yellow(msgType));
            debugLog("SERVER received " + hexDump(data));
        }
        if (msgType === "HEL") {
            try {
                (0, node_opcua_assert_1.assert)(data.length >= 24);
                const helloMessage = (0, tools_1.decodeMessage)(stream, HelloMessage_1.HelloMessage);
                // OPCUA Spec 1.03 part 6 - page 41
                // The Server shall always accept versions greater than what it supports.
                if (helloMessage.protocolVersion !== this.protocolVersion) {
                    // istanbul ignore next
                    doDebug &&
                        debugLog(`warning ! client sent helloMessage.protocolVersion = ` +
                            ` 0x${helloMessage.protocolVersion.toString(16)} ` +
                            `whereas server protocolVersion is 0x${this.protocolVersion.toString(16)}`);
                }
                if (helloMessage.protocolVersion === 0xdeadbeef || helloMessage.protocolVersion < this.protocolVersion) {
                    // Note: 0xDEADBEEF is our special version number to simulate BadProtocolVersionUnsupported in tests
                    // invalid protocol version requested by client
                    return this._abortWithError(node_opcua_status_code_1.StatusCodes.BadProtocolVersionUnsupported, "Protocol Version Error" + this.protocolVersion, callback);
                }
                // OPCUA Spec 1.04 part 6 - page 45
                // UASC is designed to operate with different TransportProtocols that may have limited buffer
                // sizes. For this reason, OPC UA Secure Conversation will break OPC UA Messages into several
                // pieces (called ‘MessageChunks’) that are smaller than the buffer size allowed by the
                // TransportProtocol. UASC requires a TransportProtocol buffer size that is at least 8 192 bytes
                if (helloMessage.receiveBufferSize < minimumBufferSize || helloMessage.sendBufferSize < minimumBufferSize) {
                    return this._abortWithError(node_opcua_status_code_1.StatusCodes.BadConnectionRejected, "Buffer size too small (should be at least " + minimumBufferSize, callback);
                }
                // the helloMessage shall only be received once.
                this._helloReceived = true;
                this._send_ACK_response(helloMessage);
            }
            catch (err) {
                // connection rejected because of malformed message
                return this._abortWithError(node_opcua_status_code_1.StatusCodes.BadConnectionRejected, util_1.types.isNativeError(err) ? err.message : "", callback);
            }
            callback(); // no Error
        }
        else {
            // invalid packet , expecting HEL
            /* istanbul ignore next*/
            doDebug && debugLog(chalk.red("BadCommunicationError ") + "Expecting 'HEL' message to initiate communication");
            this._abortWithError(node_opcua_status_code_1.StatusCodes.BadCommunicationError, "Expecting 'HEL' message to initiate communication", callback);
        }
    }
}
ServerTCP_transport.throttleTime = 1000;
exports.ServerTCP_transport = ServerTCP_transport;
//# sourceMappingURL=server_tcp_transport.js.map